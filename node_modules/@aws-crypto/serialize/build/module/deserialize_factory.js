/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * This public interface for parsing the AWS Encryption SDK Message Header Format
 * is provided for the use of the Encryption SDK for JavaScript only.  It can be used
 * as a reference but is not intended to be use by any packages other than the
 * Encryption SDK for JavaScript.
 *
 * See: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#header-structure
 */
import { // eslint-disable-line no-unused-vars
AlgorithmSuiteIdentifier, // eslint-disable-line no-unused-vars
EncryptedDataKey, // eslint-disable-line no-unused-vars
needs } from '@aws-crypto/material-management';
import { readElements } from './read_element';
// To deal with Browser and Node.js I inject a function to handle utf8 encoding.
export function deserializeFactory(toUtf8, SdkSuite) {
    return {
        deserializeMessageHeader,
        deserializeEncryptedDataKeys,
        decodeEncryptionContext
    };
    /**
     * deserializeMessageHeader
     *
     * I need to be able to parse the MessageHeader, but since the data may be streamed
     * I may not have all the data yet.  The caller is expected to maintain and append
     * to the buffer and call this function with the same readPos until the function
     * returns a HeaderInfo.
     *
     * @param messageBuffer
     * @returns HeaderInfo|undefined
     */
    function deserializeMessageHeader(messageBuffer) {
        /* Uint8Array is a view on top of the underlying ArrayBuffer.
         * This means that raw underlying memory stored in the ArrayBuffer
         * may be larger than the Uint8Array.  This is especially true of
         * the Node.js Buffer object.  The offset and length *must* be
         * passed to the DataView otherwise I will get unexpected results.
         */
        const dataView = new DataView(messageBuffer.buffer, messageBuffer.byteOffset, messageBuffer.byteLength);
        /* Check for early return (Postcondition): Not Enough Data. Need to have at least 22 bytes of data to begin parsing.
         * The first 22 bytes of the header are fixed length.  After that
         * there are 2 variable length sections.
         */
        if (dataView.byteLength < 22)
            return false; // not enough data
        const version = dataView.getUint8(0);
        const type = dataView.getUint8(1);
        /* Precondition: version and type must be the required values. */
        needs(version === 1 && type === 128, version === 65 && type === 89 ? 'Malformed Header: This blob may be base64 encoded.' : 'Malformed Header.');
        const suiteId = dataView.getUint16(2, false); // big endian
        /* Precondition: suiteId must match supported algorithm suite */
        needs(AlgorithmSuiteIdentifier[suiteId], 'Unsupported algorithm suite.');
        const messageId = messageBuffer.slice(4, 20);
        const contextLength = dataView.getUint16(20, false); // big endian
        /* Check for early return (Postcondition): Not Enough Data. Need to have all of the context in bytes before we can parse the next section.
         * This is the first variable length section.
         */
        if (22 + contextLength > dataView.byteLength)
            return false; // not enough data
        const encryptionContext = decodeEncryptionContext(messageBuffer.slice(22, 22 + contextLength));
        const dataKeyInfo = deserializeEncryptedDataKeys(messageBuffer, 22 + contextLength);
        /* Check for early return (Postcondition): Not Enough Data. deserializeEncryptedDataKeys will return false if it does not have enough data.
         * This is the second variable length section.
         */
        if (!dataKeyInfo)
            return false; // not enough data
        const { encryptedDataKeys, readPos } = dataKeyInfo;
        /* I'm doing this here, after decodeEncryptionContext and deserializeEncryptedDataKeys
         * because they are the bulk of the header section.
         */
        const algorithmSuite = new SdkSuite(suiteId);
        const { ivLength, tagLength } = algorithmSuite;
        const tagLengthBytes = tagLength / 8;
        const headerLength = readPos + 1 + 4 + 1 + 4;
        /* Check for early return (Postcondition): Not Enough Data. Need to have the remaining fixed length data to parse. */
        if (headerLength + ivLength + tagLengthBytes > dataView.byteLength)
            return false; // not enough data
        const contentType = dataView.getUint8(readPos);
        const reservedBytes = dataView.getUint32(readPos + 1, false); // big endian
        /* Postcondition: reservedBytes are defined as 0,0,0,0
         * See: https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#header-reserved
         */
        needs(reservedBytes === 0, 'Malformed Header');
        const headerIvLength = dataView.getUint8(readPos + 1 + 4);
        /* Postcondition: The headerIvLength must match the algorithm suite specification. */
        needs(headerIvLength === ivLength, 'Malformed Header');
        const frameLength = dataView.getUint32(readPos + 1 + 4 + 1, false); // big endian
        const rawHeader = messageBuffer.slice(0, headerLength);
        const messageHeader = {
            version,
            type,
            suiteId,
            messageId,
            encryptionContext,
            encryptedDataKeys,
            contentType,
            headerIvLength,
            frameLength
        };
        const headerIv = messageBuffer.slice(headerLength, headerLength + ivLength);
        const headerAuthTag = messageBuffer.slice(headerLength + ivLength, headerLength + ivLength + tagLengthBytes);
        return {
            messageHeader,
            headerLength,
            rawHeader,
            algorithmSuite,
            headerIv,
            headerAuthTag
        };
    }
    /**
     * Exported for testing.  Used by deserializeMessageHeader to compose a complete solution.
     * @param buffer Uint8Array
     * @param startPos number
     */
    function deserializeEncryptedDataKeys(buffer, startPos) {
        /* Precondition: startPos must be within the byte length of the buffer given. */
        needs(buffer.byteLength >= startPos && startPos >= 0, 'startPos out of bounds.');
        /* Check for early return (Postcondition): Need to have at least Uint16 (2) bytes of data. */
        if (startPos + 2 > buffer.byteLength)
            return false;
        /* Uint8Array is a view on top of the underlying ArrayBuffer.
         * This means that raw underlying memory stored in the ArrayBuffer
         * may be larger than the Uint8Array.  This is especially true of
         * the Node.js Buffer object.  The offset and length *must* be
         * passed to the DataView otherwise I will get unexpected results.
         */
        const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        const encryptedDataKeysCount = dataView.getUint16(startPos, false); // big endian
        /* Precondition: There must be at least 1 EncryptedDataKey element. */
        needs(encryptedDataKeysCount, 'No EncryptedDataKey found.');
        const elementInfo = readElements(encryptedDataKeysCount, 3, buffer, startPos + 2);
        /* Check for early return (Postcondition): readElement will return false if there is not enough data.
         * I can only continue if I have at least the entire EDK section.
         */
        if (!elementInfo)
            return false;
        const { elements, readPos } = elementInfo;
        const encryptedDataKeys = elements.map(([rawId, rawInfo, encryptedDataKey], _) => {
            const providerId = toUtf8(rawId);
            const providerInfo = toUtf8(rawInfo);
            return new EncryptedDataKey({ providerInfo, providerId, encryptedDataKey, rawInfo });
        });
        Object.freeze(encryptedDataKeys);
        return { encryptedDataKeys, readPos };
    }
    /**
     * Exported for testing.  Used by deserializeMessageHeader to compose a complete solution.
     * @param encodedEncryptionContext Uint8Array
     */
    function decodeEncryptionContext(encodedEncryptionContext) {
        const encryptionContext = Object.create(null);
        /* Check for early return (Postcondition): The case of 0 length is defined as an empty object. */
        if (!encodedEncryptionContext.byteLength) {
            return encryptionContext;
        }
        /* Uint8Array is a view on top of the underlying ArrayBuffer.
         * This means that raw underlying memory stored in the ArrayBuffer
         * may be larger than the Uint8Array.  This is especially true of
         * the Node.js Buffer object.  The offset and length *must* be
         * passed to the DataView otherwise I will get unexpected results.
         */
        const dataView = new DataView(encodedEncryptionContext.buffer, encodedEncryptionContext.byteOffset, encodedEncryptionContext.byteLength);
        const pairsCount = dataView.getUint16(0, false); // big endian
        const elementInfo = readElements(pairsCount, 2, encodedEncryptionContext, 2);
        /* Postcondition: Since the encryption context has a length, it must have pairs.
         * Unlike the encrypted data key section, the encryption context has a length
         * element.  This means I should always pass the entire section.
         */
        if (!elementInfo)
            throw new Error('context parse error');
        const { elements, readPos } = elementInfo;
        /* Postcondition: The byte length of the encodedEncryptionContext must match the readPos. */
        needs(encodedEncryptionContext.byteLength === readPos, 'Overflow, too much data.');
        for (let count = 0; count < pairsCount; count++) {
            const [key, value] = elements[count].map(toUtf8);
            /* Postcondition: The number of keys in the encryptionContext must match the pairsCount.
             * If the same Key value is serialized...
             */
            needs(encryptionContext[key] === undefined, 'Duplicate encryption context key value.');
            encryptionContext[key] = value;
        }
        Object.freeze(encryptionContext);
        return encryptionContext;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVzZXJpYWxpemVfZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZXNlcmlhbGl6ZV9mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFFSDs7Ozs7OztHQU9HO0FBRUgsT0FBTyxFQUNLLHFDQUFxQztBQUMvQyx3QkFBd0IsRUFDUixxQ0FBcUM7QUFDckQsZ0JBQWdCLEVBQ0cscUNBQXFDO0FBQ3hELEtBQUssRUFDTixNQUFNLGlDQUFpQyxDQUFBO0FBRXhDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQTtBQUU3QyxnRkFBZ0Y7QUFDaEYsTUFBTSxVQUFVLGtCQUFrQixDQUNoQyxNQUFxQyxFQUNyQyxRQUEwQztJQUUxQyxPQUFPO1FBQ0wsd0JBQXdCO1FBQ3hCLDRCQUE0QjtRQUM1Qix1QkFBdUI7S0FDeEIsQ0FBQTtJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxTQUFTLHdCQUF3QixDQUFFLGFBQXlCO1FBQzFEOzs7OztXQUtHO1FBQ0gsTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQzNCLGFBQWEsQ0FBQyxNQUFNLEVBQ3BCLGFBQWEsQ0FBQyxVQUFVLEVBQ3hCLGFBQWEsQ0FBQyxVQUFVLENBQ3pCLENBQUE7UUFFRDs7O1dBR0c7UUFDSCxJQUFJLFFBQVEsQ0FBQyxVQUFVLEdBQUcsRUFBRTtZQUFFLE9BQU8sS0FBSyxDQUFBLENBQUMsa0JBQWtCO1FBRTdELE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDcEMsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUNqQyxpRUFBaUU7UUFDakUsS0FBSyxDQUFDLE9BQU8sS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLEdBQUcsRUFDakMsT0FBTyxLQUFLLEVBQUUsSUFBSSxJQUFJLEtBQUssRUFBRSxD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
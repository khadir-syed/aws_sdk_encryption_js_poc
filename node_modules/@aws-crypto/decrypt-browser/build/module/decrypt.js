/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { WebCryptoAlgorithmSuite, KeyringWebCrypto, WebCryptoDefaultCryptographicMaterialsManager, getDecryptionHelper, // eslint-disable-line no-unused-vars
needs } from '@aws-crypto/material-management-browser';
import { deserializeSignature, // eslint-disable-line no-unused-vars
deserializeFactory, kdfInfo, decodeBodyHeader, aadFactory, concatBuffers, der2raw } from '@aws-crypto/serialize';
import { fromUtf8, toUtf8 } from '@aws-sdk/util-utf8-browser';
const deserialize = deserializeFactory(toUtf8, WebCryptoAlgorithmSuite);
const { messageAADContentString, messageAAD } = aadFactory(fromUtf8);
export async function decrypt(cmm, ciphertext) {
    /* If the cmm is a Keyring, wrap it with WebCryptoDefaultCryptographicMaterialsManager. */
    cmm = cmm instanceof KeyringWebCrypto
        ? new WebCryptoDefaultCryptographicMaterialsManager(cmm)
        : cmm;
    const headerInfo = deserialize.deserializeMessageHeader(ciphertext);
    if (headerInfo === false)
        throw new Error('Unable to parse Header');
    const { messageHeader } = headerInfo;
    const { rawHeader, headerIv, headerAuthTag } = headerInfo;
    const { encryptionContext, encryptedDataKeys, suiteId, messageId } = messageHeader;
    const suite = new WebCryptoAlgorithmSuite(suiteId);
    const material = await cmm.decryptMaterials({ suite, encryptionContext, encryptedDataKeys });
    const { kdfGetSubtleDecrypt, subtleVerify, dispose } = await getDecryptionHelper(material);
    const info = kdfInfo(suiteId, messageId);
    const getSubtleDecrypt = kdfGetSubtleDecrypt(info);
    // The tag is appended to the Data
    await getSubtleDecrypt(headerIv, rawHeader)(headerAuthTag); // will throw if invalid
    const { plaintext, readPos } = await bodyDecrypt({ buffer: ciphertext, getSubtleDecrypt, headerInfo });
    dispose();
    if (subtleVerify) {
        const data = ciphertext.slice(0, readPos);
        const signatureInfo = ciphertext.slice(readPos);
        const derSignature = deserializeSignature(signatureInfo);
        const rawSignature = der2raw(derSignature, material.suite);
        const isValid = await subtleVerify(rawSignature, data);
        /* Postcondition: subtleVerify must validate the signature. */
        needs(isValid, 'Invalid Signature');
        return { messageHeader, plaintext };
    }
    else {
        return { messageHeader, plaintext };
    }
}
async function bodyDecrypt({ buffer, getSubtleDecrypt, headerInfo }) {
    let readPos = headerInfo.headerIv.byteLength + headerInfo.rawHeader.byteLength + headerInfo.headerAuthTag.byteLength;
    const clearBuffers = [];
    let sequenceNumber = 0;
    while (true) {
        /* Keeping track of the sequence number myself. */
        sequenceNumber += 1;
        const { clearBlob, frameInfo } = await framedDecrypt({ buffer, getSubtleDecrypt, headerInfo, readPos });
        /* Precondition: The sequenceNumber is required to monotonically increase, starting from 1.
         * This is to avoid a bad actor from abusing the sequence number on un-signed algorithm suites.
         * If the frame size matched the data format (say NDJSON),
         * then the data could be significantly altered just by rearranging the frames.
         * Non-framed data returns a sequenceNumber of 1.
         */
        needs(frameInfo.sequenceNumber === sequenceNumber, 'Encrypted body sequence out of order.');
        clearBuffers.push(clearBlob);
        readPos = frameInfo.readPos;
        if (frameInfo.isFinalFrame) {
            const plaintext = concatBuffers(...clearBuffers);
            return { plaintext, readPos };
        }
    }
}
/* As we move to deprecate non-framed encrypt it is important to continue to support
 * non-framed decrypt.  The names not-withstanding, this supports non-framed decrypt
 * See decodeBodyHeader (it abstracts framed and non-framed body headers)
 */
async function framedDecrypt({ buffer, getSubtleDecrypt, headerInfo, readPos }) {
    const { messageHeader: { messageId } } = headerInfo;
    const frameInfo = decodeBodyHeader(buffer, headerInfo, readPos);
    if (!frameInfo)
        throw new Error('Format Error');
    const cipherLength = frameInfo.contentLength + frameInfo.tagLength / 8;
    const contentString = messageAADContentString(frameInfo);
    const messageAdditionalData = messageAAD(messageId, contentString, frameInfo.sequenceNumber, frameInfo.contentLength);
    const cipherBlob = buffer.slice(frameInfo.readPos, frameInfo.readPos + cipherLength);
    const clearBlob = await getSubtleDecrypt(frameInfo.iv, messageAdditionalData)(cipherBlob);
    frameInfo.readPos += cipherLength;
    return { clearBlob, frameInfo };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjcnlwdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWNyeXB0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFFSCxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLGdCQUFnQixFQUNoQiw2Q0FBNkMsRUFDN0MsbUJBQW1CLEVBQ0QscUNBQXFDO0FBQ3ZELEtBQUssRUFFTixNQUFNLHlDQUF5QyxDQUFBO0FBQ2hELE9BQU8sRUFDTCxvQkFBb0IsRUFDTCxxQ0FBcUM7QUFDcEQsa0JBQWtCLEVBQ2xCLE9BQU8sRUFDUCxnQkFBZ0IsRUFDaEIsVUFBVSxFQUNWLGFBQWEsRUFDYixPQUFPLEVBRVIsTUFBTSx1QkFBdUIsQ0FBQTtBQUM5QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLDRCQUE0QixDQUFBO0FBRTdELE1BQU0sV0FBVyxHQUFHLGtCQUFrQixDQUFDLE1BQU0sRUFBRSx1QkFBdUIsQ0FBQyxDQUFBO0FBQ3ZFLE1BQU0sRUFBRSx1QkFBdUIsRUFBRSxVQUFVLEVBQUUsR0FBRyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUE7QUFPcEUsTUFBTSxDQUFDLEtBQUssVUFBVSxPQUFPLENBQzNCLEdBQStDLEVBQy9DLFVBQXNCO0lBRXRCLDBGQUEwRjtJQUMxRixHQUFHLEdBQUcsR0FBRyxZQUFZLGdCQUFnQjtRQUNuQyxDQUFDLENBQUMsSUFBSSw2Q0FBNkMsQ0FBQyxHQUFHLENBQUM7UUFDeEQsQ0FBQyxDQUFDLEdBQUcsQ0FBQTtJQUVQLE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyx3QkFBd0IsQ0FBQyxVQUFVLENBQUMsQ0FBQTtJQUNuRSxJQUFJLFVBQVUsS0FBSyxLQUFLO1FBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFBO0lBQ25FLE1BQU0sRUFBRSxhQUFhLEVBQUUsR0FBRyxVQUFVLENBQUE7SUFDcEMsTUFBTSxFQUFFLFNBQVMsRUFB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
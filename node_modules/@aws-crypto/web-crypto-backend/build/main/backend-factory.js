"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ie11_detection_1 = require("@aws-crypto/ie11-detection");
const supports_web_crypto_1 = require("@aws-crypto/supports-web-crypto");
const synchronous_random_values_1 = require("./synchronous_random_values");
const promisify_ms_crypto_1 = __importDefault(require("./promisify-ms-crypto"));
function webCryptoBackendFactory(window) {
    const fallbackRequiredPromise = windowRequiresFallback(window);
    let webCryptoFallbackPromise = false;
    return { getWebCryptoBackend, configureFallback };
    async function getWebCryptoBackend() {
        /* Precondition: Access to a secure random source is required. */
        try {
            synchronous_random_values_1.synchronousRandomValues(1);
        }
        catch (ex) {
            throw new Error('No supported secure random');
        }
        const fallbackRequired = await fallbackRequiredPromise;
        const subtle = pluckSubtleCrypto(window);
        const webCryptoFallback = await webCryptoFallbackPromise;
        /* Postcondition: If a a subtle backend exists and a fallback is required, one must be configured.
         * In this case the subtle backend does not support zero byte GCM operations.
         */
        if (subtle && fallbackRequired && !webCryptoFallback) {
            throw new Error('A Fallback is required for zero byte AES-GCM operations.');
        }
        /* Postcondition: If no SubtleCrypto exists, a fallback must configured. */
        if (!subtle && !webCryptoFallback) {
            throw new Error('A Fallback is required because no subtle backend exists.');
        }
        if (!fallbackRequired && subtle) {
            return { subtle, randomValues: synchronous_random_values_1.synchronousRandomValues };
        }
        if (fallbackRequired && subtle && webCryptoFallback) {
            return { nonZeroByteSubtle: subtle, randomValues: synchronous_random_values_1.synchronousRandomValues, zeroByteSubtle: webCryptoFallback };
        }
        if (fallbackRequired && !subtle && webCryptoFallback) {
            return { subtle: webCryptoFallback, randomValues: synchronous_random_values_1.synchronousRandomValues };
        }
        throw new Error('unknown error');
    }
    async function configureFallback(fallback) {
        const fallbackRequired = await fallbackRequiredPromise;
        /* Precondition: If a fallback is not required, do not configure one. */
        if (!fallbackRequired) {
            return;
        }
        /* Precondition: Can not reconfigure fallback. */
        if (webCryptoFallbackPromise)
            throw new Error('Fallback reconfiguration denied');
        /* Precondition: Fallback must look like it supports the required operations. */
        if (!supports_web_crypto_1.supportsSubtleCrypto(fallback))
            throw new Error('Fallback does not support WebCrypto');
        // This if to lock the fallback.
        // when using the fallback, it is simpler
        // for the customer to not await the success
        // of configuration so we handle it for them
        // I still return in case they want to await
        webCryptoFallbackPromise = supports_web_crypto_1.supportsZeroByteGCM(fallback)
            .then(zeroByteGCMSupport => {
            /* Postcondition: The fallback must specifically support ZeroByteGCM. */
            if (!zeroByteGCMSupport)
                throw new Error('Fallback does not support zero byte AES-GCM');
            return fallback;
        });
        return webCryptoFallbackPromise;
    }
}
exports.webCryptoBackendFactory = webCryptoBackendFactory;
function getNonZeroByteBackend(backend) {
    /* Precondition: A backend must be passed to get a non zero byte backend. */
    if (!backend)
        throw new Error('No supported backend.');
    return backend.subtle ||
        backend.nonZeroByteSubtle;
}
exports.getNonZeroByteBackend = getNonZeroByteBackend;
function getZeroByteSubtle(backend) {
    /* Precondition: A backend must be passed to get a zero byte backend. */
    if (!backend)
        throw new Error('No supported backend.');
    return backend.subtle ||
        backend.zeroByteSubtle;
}
exports.getZeroByteSubtle = getZeroByteSubtle;
async function windowRequiresFallback(window) {
    const subtle = pluckSubtleCrypto(window);
    if (!subtle)
        return true;
    const zeroByteSupport = await supports_web_crypto_1.supportsZeroByteGCM(subtle);
    return !zeroByteSupport;
}
exports.windowRequiresFallback = windowRequiresFallback;
function pluckSubtleCrypto(window) {
    // if needed webkitSubtle check should be added here
    // see: https://webkit.org/blog/7790/update-on-web-cryptography/
    if (supports_web_crypto_1.supportsWebCrypto(window))
        return window.crypto.subtle;
    if (ie11_detection_1.isMsWindow(window))
        return promisify_ms_crypto_1.default(window.msCrypto.subtle);
    return false;
}
exports.pluckSubtleCrypto = pluckSubtleCrypto;
function isFullSupportWebCryptoBackend(backend) {
    return !!backend.subtle;
}
exports.isFullSupportWebCryptoBackend = isFullSupportWebCryptoBackend;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC1mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2JhY2tlbmQtZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7R0FhRzs7Ozs7QUFFSCwrREFBdUQ7QUFDdkQseUVBQThHO0FBQzlHLDJFQUFxRjtBQUNyRixnRkFBMkQ7QUFjM0QsU0FBZ0IsdUJBQXVCLENBQUUsTUFBYztJQUNyRCxNQUFNLHVCQUF1QixHQUFHLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQzlELElBQUksd0JBQXdCLEdBQWdDLEtBQUssQ0FBQTtJQUVqRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQTtJQUVqRCxLQUFLLFVBQVUsbUJBQW1CO1FBQ2hDLGlFQUFpRTtRQUNqRSxJQUFJO1lBQ0YsbURBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQTtTQUNoQjtRQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ1gsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFBO1NBQzlDO1FBRUQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLHVCQUF1QixDQUFBO1FBQ3RELE1BQU0sTUFBTSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFBO1FBQ3hDLE1BQU0saUJBQWlCLEdBQUcsTUFBTSx3QkFBd0IsQ0FBQTtRQUV4RDs7V0FFRztRQUNILElBQUksTUFBTSxJQUFJLGdCQUFnQixJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDcEQsTUFBTSxJQUFJLEtBQUssQ0FBQywwREFBMEQsQ0FBQyxDQUFBO1NBQzVFO1FBRUQsMkVBQTJFO1FBQzNFLElBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUNqQyxNQUFNLElBQUksS0FBSyxDQUFDLDBEQUEwRCxDQUFDLENBQUE7U0FDNUU7UUFFRCxJQUFJLENBQUMsZ0JBQWdCLElBQUksTUFBTSxFQUFFO1lBQy9CLE9BQU8sRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFaLG1EQUFZLEVBQUUsQ0FBQTtTQUNoQztRQUVELElBQUksZ0JBQWdCLElBQUksTUFBTSxJQUFJLGlCQUFpQixFQUFFO1lBQ25ELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFaLG1EQUFZLEVBQUUsY0FBYyxFQUFFLGlCQUFpQixFQUFFLENBQUE7U0FDdEY7UUFFRCxJQUFJLGdCQUFnQixJQUFJLENBQUMsTUFBTSxJQUFJLGlCQUFpQixFQUFFO1lBQ3BELE9BQU8sRUFBRSxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsWUFBWSxFQUFaLG1EQUFZLEVBQUUsQ0FBQTtTQUNuRDtRQUVELE1BQU0sSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUE7SUFDbEMsQ0FBQztJQUVELEtBQUssVUFBVSxpQkFBaUIsQ0FBRSxRQUFzQjtRQUN0RCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sdUJBQXVCLENBQUE7UUFDdEQsd0VBQXdFO1FBQ3hFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUNyQixPQUFNO1NBQ1A7UUFFRCxpREFBaUQ7UUFDakQsSUFBSSx3QkFBd0I7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUE7UUFFaEYsZ0ZBQWdGO1FBQ2hGLElBQUksQ0FBQywwQ0FBb0IsQ0FBQyxRQUFRLENBQUM7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUE7UUFFM0YsZ0NBQWdDO1FBQ2hDLHlDQUF5QztRQUN6Qyw0Q0FBNEM7UUFDNUMsNENBQTRDO1FBQzVDLDRDQUE0QztRQUM1Qyx3QkFBd0IsR0FBRyx5Q0FBbUIsQ0FBQyxRQUFRLENBQUM7YUFDckQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEVBQUU7WUFDekIsd0VBQXdFO1lBQ3hFLElBQUksQ0FBQyxrQkFBa0I7Z0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFBO1lBQ3ZGLE9BQU8sUUFBUSxDQUFBO1FBQ2pCLENBQUMsQ0FBQyxDQUFBO1FBQ0osT0FBTyx3QkFBd0IsQ0FBQTtJQUNqQyxDQUFDO0FBQ0gsQ0FBQztBQXZFRCwwREF1RUM7QUFFRCxTQUFnQixxQkFBcUIsQ0FBRSxPQUErQjtJQUNwRSw0RUFBNEU7SUFDNUUsSUFBSSxDQUFDLE9BQU87UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUE7SUFDdEQsT0FBcUMsT0FBUSxDQUFDLE1BQU07UUFDbkIsT0FBUSxDQUFDLGlCQUFpQixDQUFBO0FBQzdELENBQUM7QUFMRCxzREFLQztBQUVELFNBQWdCLGlCQUFpQixDQUFFLE9BQStCO0lBQ2hFLHdFQUF3RTtJQUN4RSxJQUFJLENBQUMsT0FBTztRQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQTtJQUN0RCxPQUFxQyxPQUFRLENBQUMsTUFBTTtRQUNuQixPQUFRLENBQUMsY0FBYyxDQUFBO0FBQzFELENBQUM7QUFMRCw4Q0FLQztBQUVNLEtBQUssVUFBVSxzQkFBc0IsQ0FBRSxNQUFjO0lBQzFELE1BQU0sTUFBTSxHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBRXhDLElBQUksQ0FBQyxNQUFNO1FBQUUsT0FBTyxJQUFJLENBQUE7SUFDeEIsTUFBTSxlQUFlLEdBQUcsTUFBTSx5Q0FBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUN6RCxPQUFPLENBQUMsZUFBZSxDQUFBO0FBQ3pCLENBQUM7QUFORCx3REFNQztBQUVELFNBQWdCLGlCQUFpQixDQUFFLE1BQWM7SUFDL0Msb0RBQW9EO0lBQ3BELGdFQUFnRTtJQUNoRSxJQUFJLHVDQUFpQixDQUFDLE1BQU0sQ0FBQztRQUFFLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUE7SUFDMUQsSUFBSSwyQkFBVSxDQUFDLE1BQU0sQ0FBQztRQUFFLE9BQU8sNkJBQXVCLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUM5RSxPQUFPLEtBQUssQ0FBQTtBQUNkLENBQUM7QUFORCw4Q0FNQztBQUVELFNBQWdCLDZCQUE2QixDQUFFLE9BQXlCO0lBQ3RFLE9BQU8sQ0FBQyxDQUErQixPQUFRLENBQUMsTUFBTSxDQUFBO0FBQ3hELENBQUM7QUFGRCxzRUFFQyJ9
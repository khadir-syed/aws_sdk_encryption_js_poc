/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* For raw AES keyrings the required wrapping information is stored in an EncryptedDataKey.
  * KeyNamespace (identifies the keyring "class"),
  * KeyName (identifies this specific keyring, like a KMS CMK ARN)
  *
  * {
  *   providerId: KeyNamespace
  *   providerInfo: utf8Encode(KeyName + TagLengthBits uInt32BE + IVLength uInt32BE + iv)
  *   encryptedDataKey: wrapped key + authTag
  * }
  *
  * The AAD (encryption context) is the same as the message.
  */
import { concatBuffers, uInt32BE } from '@aws-crypto/serialize';
import { // eslint-disable-line no-unused-vars
EncryptedDataKey, // eslint-disable-line no-unused-vars
needs } from '@aws-crypto/material-management';
export function rawAesEncryptedDataKeyFactory(toUtf8, fromUtf8) {
    return { rawAesEncryptedDataKey };
    function rawAesEncryptedDataKey(keyNamespace, keyName, iv, ciphertext, authTag) {
        const ivLength = iv.byteLength;
        const authTagBitLength = authTag.byteLength * 8;
        const encryptedDataKey = concatBuffers(ciphertext, authTag);
        const providerId = keyNamespace;
        const rawInfo = concatBuffers(fromUtf8(keyName), uInt32BE(authTagBitLength), uInt32BE(ivLength), iv);
        const providerInfo = toUtf8(rawInfo);
        return new EncryptedDataKey({ encryptedDataKey, providerId, providerInfo, rawInfo });
    }
}
export function rawAesEncryptedPartsFactory(fromUtf8) {
    return { rawAesEncryptedParts };
    function rawAesEncryptedParts(suite, keyName, { encryptedDataKey, rawInfo }) {
        /* Precondition: rawInfo must be a Uint8Array. */
        if (!(rawInfo instanceof Uint8Array))
            throw new Error('Malformed Encrypted Data Key.');
        // see above for format, slice off the "string part"
        rawInfo = rawInfo.slice(fromUtf8(keyName).byteLength);
        /* Uint8Array is a view on top of the underlying ArrayBuffer.
          * This means that raw underlying memory stored in the ArrayBuffer
          * may be larger than the Uint8Array.  This is especially true of
          * the Node.js Buffer object.  The offset and length *must* be
          * passed to the DataView otherwise I will get unexpected results.
          */
        const dataView = new DataView(rawInfo.buffer, rawInfo.byteOffset, rawInfo.byteLength);
        /* See above:
          * uInt32BE(authTagBitLength),uInt32BE(ivLength), iv
          */
        const tagLengthBits = dataView.getUint32(0, false); // big endian
        const ivLength = dataView.getUint32(4, false); // big endian
        /* Precondition: The ivLength must match the algorith suite specification. */
        needs(ivLength === suite.ivLength, 'Malformed providerInfo');
        /* Precondition: The tagLength must match the algorith suite specification. */
        needs(tagLengthBits === suite.tagLength, 'Malformed providerInfo');
        /* Precondition: The byteLength of rawInfo should match the encoded length. */
        needs(rawInfo.byteLength === 4 + 4 + ivLength, 'Malformed providerInfo');
        const tagLength = tagLengthBits / 8;
        /* Precondition: The encryptedDataKey byteLength must match the algorith suite specification and encoded length. */
        needs(encryptedDataKey.byteLength === tagLength + suite.keyLengthBytes, 'Malformed providerInfo');
        const iv = rawInfo.slice(-ivLength);
        const authTag = encryptedDataKey.slice(-tagLength);
        const ciphertext = encryptedDataKey.slice(0, -tagLength);
        return { authTag, ciphertext, iv };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3X2Flc19lbmNyeXB0ZWRfZGF0YV9rZXlzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Jhd19hZXNfZW5jcnlwdGVkX2RhdGFfa2V5cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUg7Ozs7Ozs7Ozs7O0lBV0k7QUFFSixPQUFPLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxNQUFNLHVCQUF1QixDQUFBO0FBQy9ELE9BQU8sRUFDVyxxQ0FBcUM7QUFDckQsZ0JBQWdCLEVBQUUscUNBQXFDO0FBQ3ZELEtBQUssRUFDTixNQUFNLGlDQUFpQyxDQUFBO0FBRXhDLE1BQU0sVUFBVSw2QkFBNkIsQ0FDM0MsTUFBcUMsRUFDckMsUUFBdUM7SUFFdkMsT0FBTyxFQUFFLHNCQUFzQixFQUFFLENBQUE7SUFFakMsU0FBUyxzQkFBc0IsQ0FDN0IsWUFBb0IsRUFDcEIsT0FBZSxFQUNmLEVBQWMsRUFDZCxVQUFzQixFQUN0QixPQUFtQjtRQUVuQixNQUFNLFFBQVEsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFBO1FBQzlCLE1BQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUE7UUFDL0MsTUFBTSxnQkFBZ0IsR0FBRyxhQUFhLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFBO1FBQzNELE1BQU0sVUFBVSxHQUFHLFlBQVksQ0FBQTtRQUMvQixNQUFNLE9BQU8sR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQTtRQUNwRyxNQUFNLFlBQVksR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDcEMsT0FBTyxJQUFJLGdCQUFnQixDQUFDLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFBO0lBQ3RGLENBQUM7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLDJCQUEyQixDQUFFLFFBQXVDO0lBQ2xGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxDQUFBO0lBRS9CLFNBQVMsb0JBQW9CLENBQzNCLEtBQXFCLEVBQ3JCLE9BQWUsRUFDZixFQUFFLGdCQUFnQixFQUFFLE9BQU8sRUFBb0I7UUFFL0MsaURBQWlEO1FBQ2pELElBQUksQ0FBQyxDQUFDLE9BQU8sWUFBWSxVQUFVLENBQUM7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixDQUFDLENBQUE7UUFDdEYsb0RBQW9EO1FBQ3BELE9BQU8sR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQTtRQUNyRDs7Ozs7WUFLSTtRQUNKLE1BQU0sUUFBUSxHQUFHLElBQUksUUFBUSxDQUMzQixPQUFPLENBQUMsTUFBTSxFQUNkLE9BQU8sQ0FBQyxVQUFVLEVBQ2xCLE9BQU8sQ0FBQyxVQUFVLENBQ25CLENBQUE7UUFDRDs7WUFFSTtRQUNKLE1BQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFBLENBQUMsYUFBYTtRQUNoRSxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQSxDQUFDLGFBQWE7UUFDM0QsNkVBQTZFO1FBQzdFLEtBQUssQ0FBQyxRQUFRLEtBQUssS0FBSyxDQUFDLFFBQVEsRUFBRSx3QkFBd0IsQ0FBQyxDQUFBO1FBQzVELDhFQUE4RTtRQUM5RSxLQUFLLENBQUMsYUFBYSxLQUFLLEtBQUssQ0FBQyxTQUFTLEVBQUUsd0JBQXdCLENBQUMsQ0FBQTtRQUNsRSw4RUFBOEU7UUFDOUUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLEVBQUUsd0JBQXdCLENBQUMsQ0FBQTtRQUN4RSxNQUFNLFNBQVMsR0FBRyxhQUFhLEdBQUcsQ0FBQyxDQUFBO1FBQ25DLG1IQUFtSDtRQUNuSCxLQUFLLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxLQUFLLFNBQVMsR0FBRyxLQUFLLENBQUMsY0FBYyxFQUFFLHdCQUF3QixDQUFDLENBQUE7UUFDakcsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ25DLE1BQU0sT0FBTyxHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFBO1FBQ2xELE1BQU0sVUFBVSxHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQTtRQUV4RCxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsQ0FBQTtJQUNwQyxDQUFDO0FBQ0gsQ0FBQyJ9
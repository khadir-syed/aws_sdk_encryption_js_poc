/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { // eslint-disable-line no-unused-vars
needs, readOnlyProperty, // eslint-disable-line no-unused-vars
cloneMaterial } from '@aws-crypto/material-management';
import { Maximum } from '@aws-crypto/serialize';
export function decorateProperties(obj, input) {
    const { cache, backingMaterialsManager, maxAge, maxBytesEncrypted, maxMessagesEncrypted, partition } = input;
    /* Precondition: A caching material manager needs a cache. */
    needs(cache, 'You must provide a cache.');
    /* Precondition: A caching material manager needs a way to get material. */
    needs(backingMaterialsManager, 'You must provide a backing material source.');
    /* Precondition: You *can not* cache something forever. */
    needs(maxAge > 0, 'You must configure a maxAge');
    /* Precondition: maxBytesEncrypted must be inside bounds.  i.e. positive and not more than the maximum. */
    needs(!maxBytesEncrypted || (maxBytesEncrypted > 0 && Maximum.BYTES_PER_CACHED_KEY_LIMIT >= maxBytesEncrypted), 'maxBytesEncrypted is outside of bounds.');
    /* Precondition: maxMessagesEncrypted must be inside bounds.  i.e. positive and not more than the maximum. */
    needs(!maxMessagesEncrypted || (maxMessagesEncrypted > 0 && Maximum.MESSAGES_PER_CACHED_KEY_LIMIT >= maxMessagesEncrypted), 'maxMessagesEncrypted is outside of bounds.');
    /* Precondition: partition must be a string. */
    needs(partition && typeof partition === 'string', 'partition must be a string.');
    readOnlyProperty(obj, '_cache', cache);
    readOnlyProperty(obj, '_backingMaterialsManager', backingMaterialsManager);
    readOnlyProperty(obj, '_maxAge', maxAge);
    readOnlyProperty(obj, '_maxBytesEncrypted', maxBytesEncrypted || Maximum.BYTES_PER_CACHED_KEY_LIMIT);
    readOnlyProperty(obj, '_maxMessagesEncrypted', maxMessagesEncrypted || Maximum.MESSAGES_PER_CACHED_KEY_LIMIT);
    readOnlyProperty(obj, '_partition', partition);
}
export function getEncryptionMaterials({ buildEncryptionMaterialCacheKey }) {
    return async function getEncryptionMaterials(request) {
        const { suite, encryptionContext, plaintextLength } = request;
        /* Check for early return (Postcondition): If I can not cache the EncryptionMaterial, do not even look. */
        if ((suite && !suite.cacheSafe) || typeof plaintextLength !== 'number' || plaintextLength < 0) {
            return this
                ._backingMaterialsManager
                .getEncryptionMaterials(request);
        }
        const cacheKey = await buildEncryptionMaterialCacheKey(this._partition, { suite, encryptionContext });
        const entry = this._cache.getEncryptionMaterial(cacheKey, plaintextLength);
        /* Check for early return (Postcondition): If I have a valid EncryptionMaterial, return it. */
        if (entry && !this._cacheEntryHasExceededLimits(entry)) {
            return cloneResponse(entry.response);
        }
        else {
            this._cache.del(cacheKey);
        }
        const material = await this
            ._backingMaterialsManager
            /* Strip any information about the plaintext from the backing request,
             * because the resulting response may be used to encrypt multiple plaintexts.
             */
            .getEncryptionMaterials({ suite, encryptionContext, plaintextLength });
        /* Check for early return (Postcondition): If I can not cache the EncryptionMaterial, just return it. */
        if (!material.suite.cacheSafe)
            return material;
        /* It is possible for an entry to exceed limits immediately.
         * The simplest case is to need to encrypt more than then maxBytesEncrypted.
         * In this case, I return the response to encrypt the data,
         * but do not put a know invalid item into the cache.
         */
        const testEntry = {
            response: material,
            now: Date.now(),
            messagesEncrypted: 1,
            bytesEncrypted: plaintextLength
        };
        if (!this._cacheEntryHasExceededLimits(testEntry)) {
            this._cache.putEncryptionMaterial(cacheKey, material, plaintextLength, this._maxAge);
            return cloneResponse(material);
        }
        else {
            /* Postcondition: If the material has exceeded limits it MUST NOT be cloned.
             * If it is cloned, and the clone is returned,
             * then there exist a copy of the unencrypted data key.
             * It is true that this data would be caught by GC, it is better to just not rely on that.
             */
            return material;
        }
    };
}
export function decryptMaterials({ buildDecryptionMaterialCacheKey }) {
    return async function decryptMaterials(request) {
        const { suite } = request;
        /* Check for early return (Postcondition): If I can not cache the DecryptionMaterial, do not even look. */
        if (!suite.cacheSafe) {
            return this
                ._backingMaterialsManager
                .decryptMaterials(request);
        }
        const cacheKey = await buildDecryptionMaterialCacheKey(this._partition, request);
        const entry = this._cache.getDecryptionMaterial(cacheKey);
        /* Check for early return (Postcondition): If I have a valid DecryptionMaterial, return it. */
        if (entry && !this._cacheEntryHasExceededLimits(entry)) {
            return cloneResponse(entry.response);
        }
        else {
            this._cache.del(cacheKey);
        }
        const material = await this
            ._backingMaterialsManager
            .decryptMaterials(request);
        this._cache.putDecryptionMaterial(cacheKey, material, this._maxAge);
        return cloneResponse(material);
    };
}
export function cacheEntryHasExceededLimits() {
    return function cacheEntryHasExceededLimits({ now, messagesEncrypted, bytesEncrypted }) {
        const age = Date.now() - now;
        return age > this._maxAge ||
            messagesEncrypted > this._maxMessagesEncrypted ||
            bytesEncrypted > this._maxBytesEncrypted;
    };
}
/**
 * I need to clone the underlying material.
 * Because when the Encryption SDK is done with material, it will zero it out.
 * Plucking off the material and cloning just that and then returning the rest of the response
 * can just be handled in one place.
 * @param material EncryptionMaterial|DecryptionMaterial
 * @return EncryptionMaterial|DecryptionMaterial
 */
function cloneResponse(material) {
    return cloneMaterial(material);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGluZ19jcnlwdG9ncmFwaGljX21hdGVyaWFsc19kZWNvcmF0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NhY2hpbmdfY3J5cHRvZ3JhcGhpY19tYXRlcmlhbHNfZGVjb3JhdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUgsT0FBTyxFQVFjLHFDQUFxQztBQUN4RCxLQUFLLEVBQ0wsZ0JBQWdCLEVBQ1AscUNBQXFDO0FBQzlDLGFBQWEsRUFDZCxNQUFNLGlDQUFpQyxDQUFBO0FBQ3hDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQTtBQVMvQyxNQUFNLFVBQVUsa0JBQWtCLENBQ2hDLEdBQStCLEVBQy9CLEtBQThDO0lBRTlDLE1BQU0sRUFBRSxLQUFLLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixFQUFFLG9CQUFvQixFQUFFLFNBQVMsRUFBRSxHQUFHLEtBQUssQ0FBQTtJQUU1Ryw2REFBNkQ7SUFDN0QsS0FBSyxDQUFDLEtBQUssRUFBRSwyQkFBMkIsQ0FBQyxDQUFBO0lBQ3pDLDJFQUEyRTtJQUMzRSxLQUFLLENBQUMsdUJBQXVCLEVBQUUsNkNBQTZDLENBQUMsQ0FBQTtJQUM3RSwwREFBMEQ7SUFDMUQsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsNkJBQTZCLENBQUMsQ0FBQTtJQUNoRCwwR0FBMEc7SUFDMUcsS0FBSyxDQUFDLENBQUMsaUJBQWlCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLDBCQUEwQixJQUFJLGlCQUFpQixDQUFDLEVBQUUseUNBQXlDLENBQUMsQ0FBQTtJQUMxSiw2R0FBNkc7SUFDN0csS0FBSyxDQUFDLENBQUMsb0JBQW9CLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLDZCQUE2QixJQUFJLG9CQUFvQixDQUFDLEVBQUUsNENB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
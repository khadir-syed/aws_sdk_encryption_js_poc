"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const material_management_1 = require("@aws-crypto/material-management");
const serialize_1 = require("@aws-crypto/serialize");
const web_crypto_backend_1 = require("@aws-crypto/web-crypto-backend");
const util_base64_browser_1 = require("@aws-sdk/util-base64-browser");
/**
 * The DefaultCryptographicMaterialsManager is a specific implementation of the CryptographicMaterialsManager.
 * New cryptography materials managers SHOULD extend from WebCryptoMaterialsManager.
 * Users should never need to create an instance of a DefaultCryptographicMaterialsManager.
 */
class WebCryptoDefaultCryptographicMaterialsManager {
    constructor(keyring) {
        /* Precondition: keyrings must be a KeyringWebCrypto. */
        material_management_1.needs(keyring instanceof material_management_1.KeyringWebCrypto, 'Unsupported type.');
        material_management_1.readOnlyProperty(this, 'keyring', keyring);
    }
    async getEncryptionMaterials({ suite, encryptionContext }) {
        suite = suite || new material_management_1.WebCryptoAlgorithmSuite(material_management_1.AlgorithmSuiteIdentifier.ALG_AES256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384);
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager must reserve the ENCODED_SIGNER_KEY constant from @aws-crypto/serialize.
         * A CryptographicMaterialsManager can change entries to the encryptionContext
         * but changing these values has consequences.
         * The DefaultCryptographicMaterialsManager uses the value in the encryption context to store public signing key.
         * If the caller is using this value in their encryption context the Default CMM is probably not the CMM they want to use.
         */
        material_management_1.needs(!encryptionContext.hasOwnProperty(serialize_1.ENCODED_SIGNER_KEY), `Reserved encryptionContext value ${serialize_1.ENCODED_SIGNER_KEY} not allowed.`);
        const material = await this
            .keyring
            .onEncrypt(await this._initializeEncryptionMaterial(suite, encryptionContext));
        /* Postcondition: The WebCryptoEncryptionMaterial must contain a valid dataKey.
         * This verifies that the data key matches the algorithm suite specification
         * and that the unencrypted data key is non-NULL.
         * See: cryptographic_materials.ts, `getUnencryptedDataKey`
         */
        material_management_1.needs(material.hasValidKey(), 'Unencrypted data key is invalid.');
        /* Postcondition: The WebCryptoEncryptionMaterial must contain at least 1 EncryptedDataKey. */
        material_management_1.needs(material.encryptedDataKeys.length, 'No EncryptedDataKeys: the ciphertext can never be decrypted.');
        return material;
    }
    async decryptMaterials({ suite, encryptedDataKeys, encryptionContext }) {
        const material = await this
            .keyring
            .onDecrypt(await this._initializeDecryptionMaterial(suite, encryptionContext), encryptedDataKeys.slice());
        /* Postcondition: The WebCryptoDecryptionMaterial must contain a valid dataKey.
         * See: cryptographic_materials.ts, `getUnencryptedDataKey` also verifies
         * that the unencrypted data key has not been manipulated,
         * that the data key matches the algorithm suite specification
         * and that the unencrypted data key is non-NULL.
         */
        material_management_1.needs(material.hasValidKey(), 'Unencrypted data key is invalid.');
        return material;
    }
    async _initializeEncryptionMaterial(suite, encryptionContext) {
        const { signatureCurve: namedCurve } = suite;
        /* Check for early return (Postcondition): The WebCryptoAlgorithmSuite specification must support a signatureCurve to generate a signing key. */
        if (!namedCurve)
            return new material_management_1.WebCryptoEncryptionMaterial(suite, encryptionContext);
        const backend = await web_crypto_backend_1.getWebCryptoBackend();
        const subtle = web_crypto_backend_1.getNonZeroByteBackend(backend);
        const webCryptoAlgorithm = { name: 'ECDSA', namedCurve };
        const extractable = false;
        const usages = ['sign'];
        const format = 'raw';
        const { publicKey, privateKey } = await subtle.generateKey(webCryptoAlgorithm, extractable, usages);
        const publicKeyBytes = await subtle.exportKey(format, publicKey);
        const compressPoint = material_management_1.SignatureKey.encodeCompressPoint(new Uint8Array(publicKeyBytes), suite);
        const signatureKey = new material_management_1.SignatureKey(privateKey, compressPoint, suite);
        return new material_management_1.WebCryptoEncryptionMaterial(suite, { ...encryptionContext, [serialize_1.ENCODED_SIGNER_KEY]: util_base64_browser_1.toBase64(compressPoint) })
            .setSignatureKey(signatureKey);
    }
    async _initializeDecryptionMaterial(suite, encryptionContext) {
        const { signatureCurve: namedCurve } = suite;
        /* Check for early return (Postcondition): The WebCryptoAlgorithmSuite specification must support a signatureCurve to extract a verification key. */
        if (!namedCurve)
            return new material_management_1.WebCryptoDecryptionMaterial(suite, encryptionContext);
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager If the algorithm suite specification requires a signatureCurve a context must exist. */
        if (!encryptionContext)
            throw new Error('Encryption context does not contain required public key.');
        const { [serialize_1.ENCODED_SIGNER_KEY]: compressPoint } = encryptionContext;
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager The context must contain the public key. */
        material_management_1.needs(compressPoint, 'Context does not contain required public key.');
        const backend = await web_crypto_backend_1.getWebCryptoBackend();
        const subtle = web_crypto_backend_1.getNonZeroByteBackend(backend);
        const webCryptoAlgorithm = { name: 'ECDSA', namedCurve };
        const extractable = false;
        const usages = ['verify'];
        const format = 'raw';
        const publicKeyBytes = material_management_1.VerificationKey.decodeCompressPoint(util_base64_browser_1.fromBase64(compressPoint), suite);
        const publicKey = await subtle.importKey(format, publicKeyBytes, webCryptoAlgorithm, extractable, usages);
        return new material_management_1.WebCryptoDecryptionMaterial(suite, encryptionContext)
            .setVerificationKey(new material_management_1.VerificationKey(publicKey, suite));
    }
}
exports.WebCryptoDefaultCryptographicMaterialsManager = WebCryptoDefaultCryptographicMaterialsManager;
material_management_1.immutableBaseClass(WebCryptoDefaultCryptographicMaterialsManager);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvd3Nlcl9jcnlwdG9ncmFwaGljX21hdGVyaWFsc19tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Jyb3dzZXJfY3J5cHRvZ3JhcGhpY19tYXRlcmlhbHNfbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7R0FhRzs7QUFFSCx5RUFPd0M7QUFFeEMscURBQTBEO0FBQzFELHVFQUEyRjtBQUMzRixzRUFBbUU7QUFPbkU7Ozs7R0FJRztBQUNILE1BQWEsNkNBQTZDO0lBRXhELFlBQWEsT0FBeUI7UUFDcEMsd0RBQXdEO1FBQ3hELDJCQUFLLENBQUMsT0FBTyxZQUFZLHNDQUFnQixFQUFFLG1CQUFtQixDQUFDLENBQUE7UUFDL0Qsc0NBQWdCLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQTtJQUM1QyxDQUFDO0lBQ0QsS0FBSyxDQUFDLHNCQUFzQixDQUFFLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixFQUE4QjtRQUNwRixLQUFLLEdBQUcsS0FBSyxJQUFJLElBQUksNkNBQXVCLENBQUMsOENBQXdCLENBQUMsZ0RBQWdELENBQUMsQ0FBQTtRQUV2SDs7Ozs7V0FLRztRQUNILDJCQUFLLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsOEJBQWtCLENBQUMsRUFBRSxvQ0FBb0MsOEJBQWtCLGVBQWUsQ0FBQyxDQUFBO1FBRW5JLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSTthQUN4QixPQUFPO2FBQ1AsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDLDZCQUE2QixDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLENBQUE7UUFFaEY7Ozs7V0FJRztRQUNILDJCQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxFQUFFLGtDQUFrQyxDQUFDLENBQUE7UUFFakUsOEZBQThGO1FBQzlGLDJCQUFLLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLE1B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
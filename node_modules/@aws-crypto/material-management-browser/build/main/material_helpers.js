"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const material_management_1 = require("@aws-crypto/material-management");
const web_crypto_backend_1 = require("@aws-crypto/web-crypto-backend");
const bytes2_jwk_1 = require("./bytes2_jwk");
exports.getEncryptHelper = async (material) => {
    const backend = await web_crypto_backend_1.getWebCryptoBackend();
    /* Precondition: WebCryptoEncryptionMaterial must have a valid data key. */
    material_management_1.needs(material.hasValidKey(), 'Material has no CryptoKey.');
    const { signatureHash } = material.suite;
    const kdfGetSubtleEncrypt = getSubtleFunction(material, backend, 'encrypt');
    return Object.freeze({
        kdfGetSubtleEncrypt,
        subtleSign: signatureHash ? getSubtleSign : undefined,
        dispose
    });
    function getSubtleSign(data) {
        if (!signatureHash)
            throw new Error('Algorithm suite does not support signing.');
        const { signatureKey } = material;
        if (!signatureKey)
            throw new Error('Malformed Material.');
        const { privateKey } = signatureKey;
        if (!material_management_1.isCryptoKey(privateKey))
            throw new Error('Malformed Material.');
        const algorithm = { name: 'ECDSA', hash: { name: signatureHash } };
        return web_crypto_backend_1.getNonZeroByteBackend(backend).sign(algorithm, privateKey, data);
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
exports.getDecryptionHelper = async (material) => {
    const backend = await web_crypto_backend_1.getWebCryptoBackend();
    /* Precondition: WebCryptoDecryptionMaterial must have a valid data key. */
    material_management_1.needs(material.hasValidKey(), 'Material has no valid data key.');
    const { signatureHash } = material.suite;
    const kdfGetSubtleDecrypt = getSubtleFunction(material, backend, 'decrypt');
    return Object.freeze({
        kdfGetSubtleDecrypt,
        subtleVerify: signatureHash ? subtleVerify : undefined,
        dispose
    });
    function subtleVerify(signature, data) {
        if (!signatureHash)
            throw new Error('Algorithm suite does not support signing.');
        const { verificationKey } = material;
        if (!verificationKey)
            throw new Error('Malformed Material.');
        const { publicKey } = verificationKey;
        if (!material_management_1.isCryptoKey(publicKey))
            throw new Error('Malformed Material.');
        const algorithm = { name: 'ECDSA', hash: { name: signatureHash } };
        return web_crypto_backend_1.getNonZeroByteBackend(backend).verify(algorithm, publicKey, signature, data);
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
function getSubtleFunction(material, backend, subtleFunction = material_management_1.subtleFunctionForMaterial(material)) {
    /* Precondition: The material must have a CryptoKey. */
    material_management_1.needs(material.hasCryptoKey, 'Material must have a CryptoKey.');
    const cryptoKey = material.getCryptoKey();
    /* Precondition: The cryptoKey and backend must match in terms of Mixed vs Full support. */
    material_management_1.needs(material_management_1.isCryptoKey(cryptoKey) === web_crypto_backend_1.isFullSupportWebCryptoBackend(backend), 'CryptoKey vs WebCrypto backend mismatch.');
    const { suite } = material;
    const { encryption: cipherName, ivLength, tagLength } = suite;
    return (info) => {
        const derivedKeyPromise = material_management_1.isCryptoKey(cryptoKey)
            ? WebCryptoKdf(web_crypto_backend_1.getNonZeroByteBackend(backend), material, cryptoKey, [subtleFunction], info)
            : Promise.all([
                WebCryptoKdf(web_crypto_backend_1.getNonZeroByteBackend(backend), material, cryptoKey.nonZeroByteCryptoKey, [subtleFunction], info),
                WebCryptoKdf(web_crypto_backend_1.getZeroByteSubtle(backend), material, cryptoKey.zeroByteCryptoKey, [subtleFunction], info)
            ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({ nonZeroByteCryptoKey, zeroByteCryptoKey }));
        return (iv, additionalData) => {
            /* Precondition: The length of the IV must match the WebCryptoAlgorithmSuite specification. */
            material_management_1.needs(iv.byteLength === ivLength, 'Iv length does not match algorithm suite specification');
            return async (data) => {
                const deriveKey = await derivedKeyPromise;
                if (material_management_1.isCryptoKey(deriveKey) && web_crypto_backend_1.isFullSupportWebCryptoBackend(backend)) {
                    const { subtle } = backend;
                    const algorithm = { name: cipherName, iv, additionalData, tagLength };
                    return subtle[subtleFunction](algorithm, deriveKey, data);
                }
                else if (!material_management_1.isCryptoKey(deriveKey) && !web_crypto_backend_1.isFullSupportWebCryptoBackend(backend)) {
                    const { nonZeroByteSubtle, zeroByteSubtle } = backend;
                    const { nonZeroByteCryptoKey, zeroByteCryptoKey } = deriveKey;
                    const algorithm = { name: cipherName, iv, additionalData, tagLength };
                    if (data.byteLength) {
                        return nonZeroByteSubtle[subtleFunction](algorithm, nonZeroByteCryptoKey, data);
                    }
                    else {
                        return zeroByteSubtle[subtleFunction](algorithm, zeroByteCryptoKey, data);
                    }
                }
                // This should be impossible
                throw new Error('Unknown Error');
            };
        };
    };
}
exports.getSubtleFunction = getSubtleFunction;
async function WebCryptoKdf(subtle, material, cryptoKey, keyUsages, info) {
    const { kdf, kdfHash, keyLength, encryption } = material.suite;
    /* Check for early return (Postcondition): No WebCrypto KDF, just return the unencrypted data key. */
    if (!kdf && !kdfHash)
        return cryptoKey;
    /* Precondition: Valid HKDF values must exist for browsers. */
    material_management_1.needs(kdf === 'HKDF' &&
        kdfHash &&
        info instanceof Uint8Array &&
        info.byteLength, 'Invalid HKDF values.');
    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    const kdfAlgorithm = { name: kdf, hash: { name: kdfHash }, info, salt: new Uint8Array() };
    const derivedKeyAlgorithm = { name: encryption, length: keyLength };
    const extractable = false;
    const deriveKey = await subtle
        .deriveKey(
    // @ts-ignore types need to be updated see: https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    kdfAlgorithm, cryptoKey, derivedKeyAlgorithm, extractable, keyUsages);
    /* Postcondition: The derived key must conform to the algorith suite specification. */
    material_management_1.needs(material_management_1.isValidCryptoKey(deriveKey, material), 'Invalid derived key');
    return deriveKey;
}
exports.WebCryptoKdf = WebCryptoKdf;
async function importCryptoKey(backend, material, keyUsages = [material_management_1.keyUsageForMaterial(material)]) {
    if (web_crypto_backend_1.isFullSupportWebCryptoBackend(backend)) {
        return _importCryptoKey(backend.subtle, material, keyUsages);
    }
    else {
        return Promise.all([
            _importCryptoKey(web_crypto_backend_1.getNonZeroByteBackend(backend), material, keyUsages),
            _importCryptoKey(web_crypto_backend_1.getZeroByteSubtle(backend), material, keyUsages)
        ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({ nonZeroByteCryptoKey, zeroByteCryptoKey }));
    }
}
exports.importCryptoKey = importCryptoKey;
async function _importCryptoKey(subtle, material, keyUsages = [material_management_1.keyUsageForMaterial(material)]) {
    const { suite } = material;
    const extractable = false;
    const udk = material_management_1.unwrapDataKey(material.getUnencryptedDataKey());
    if (suite.kdf) {
        /* For several browsers, import for a key to derive with HKDF
         * *must* be raw.  This may cause some compatibility issues
         * with browsers that need a zero byte gcm fallback.
         */
        const format = 'raw';
        const algorithm = suite.kdf;
        return subtle.importKey(format, udk, algorithm, extractable, keyUsages);
    }
    else {
        const format = 'jwk';
        const algorithm = suite.encryption;
        const jwk = bytes2_jwk_1.bytes2JWK(udk);
        return subtle.importKey(format, jwk, algorithm, extractable, keyUsages);
    }
}
exports._importCryptoKey = _importCryptoKey;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWxfaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXRlcmlhbF9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7OztHQWFHOztBQUVILHlFQVd3QztBQUV4Qyx1RUFNdUM7QUFFdkMsNkNBQXdDO0FBd0IzQixRQUFBLGdCQUFnQixHQUFxQixLQUFLLEVBQUUsUUFBcUMsRUFBRSxFQUFFO0lBQ2hHLE1BQU0sT0FBTyxHQUFHLE1BQU0sd0NBQW1CLEVBQUUsQ0FBQTtJQUUzQywyRUFBMkU7SUFDM0UsMkJBQUssQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLEVBQUUsNEJBQTRCLENBQUMsQ0FBQTtJQUUzRCxNQUFNLEVBQUUsYUFBYSxFQUFFLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQTtJQUN4QyxNQUFNLG1CQUFtQixHQUF3QixpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFBO0lBQ2hHLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNuQixtQkFBbUI7UUFDbkIsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxTQUFTO1FBQ3JELE9BQU87S0FDUixDQUFDLENBQUE7SUFFRixTQUFTLGFBQWEsQ0FBRSxJQUFnQjtRQUN0QyxJQUFJLENBQUMsYUFBYTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQTtRQUNoRixNQUFNLEVBQUUsWUFBWSxFQUFFLEdBQUcsUUFBUSxDQUFBO1FBQ2pDLElBQUksQ0FBQyxZQUFZO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO1FBQ3pELE1BQU0sRUFBRSxVQUFVLEVBQUUsR0FBRyxZQUFZLENBQUE7UUFDbkMsSUFBSSxDQUFDLGlDQUFXLENBQUMsVUFBVSxDQUFDO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FB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
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { // eslint-disable-line no-unused-vars
WebCryptoAlgorithmSuite, WebCryptoEncryptionMaterial, WebCryptoDecryptionMaterial, SignatureKey, needs, readOnlyProperty, VerificationKey, AlgorithmSuiteIdentifier, immutableBaseClass, KeyringWebCrypto } from '@aws-crypto/material-management';
import { ENCODED_SIGNER_KEY } from '@aws-crypto/serialize';
import { getWebCryptoBackend, getNonZeroByteBackend } from '@aws-crypto/web-crypto-backend';
import { fromBase64, toBase64 } from '@aws-sdk/util-base64-browser';
/**
 * The DefaultCryptographicMaterialsManager is a specific implementation of the CryptographicMaterialsManager.
 * New cryptography materials managers SHOULD extend from WebCryptoMaterialsManager.
 * Users should never need to create an instance of a DefaultCryptographicMaterialsManager.
 */
export class WebCryptoDefaultCryptographicMaterialsManager {
    constructor(keyring) {
        /* Precondition: keyrings must be a KeyringWebCrypto. */
        needs(keyring instanceof KeyringWebCrypto, 'Unsupported type.');
        readOnlyProperty(this, 'keyring', keyring);
    }
    async getEncryptionMaterials({ suite, encryptionContext }) {
        suite = suite || new WebCryptoAlgorithmSuite(AlgorithmSuiteIdentifier.ALG_AES256_GCM_IV12_TAG16_HKDF_SHA384_ECDSA_P384);
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager must reserve the ENCODED_SIGNER_KEY constant from @aws-crypto/serialize.
         * A CryptographicMaterialsManager can change entries to the encryptionContext
         * but changing these values has consequences.
         * The DefaultCryptographicMaterialsManager uses the value in the encryption context to store public signing key.
         * If the caller is using this value in their encryption context the Default CMM is probably not the CMM they want to use.
         */
        needs(!encryptionContext.hasOwnProperty(ENCODED_SIGNER_KEY), `Reserved encryptionContext value ${ENCODED_SIGNER_KEY} not allowed.`);
        const material = await this
            .keyring
            .onEncrypt(await this._initializeEncryptionMaterial(suite, encryptionContext));
        /* Postcondition: The WebCryptoEncryptionMaterial must contain a valid dataKey.
         * This verifies that the data key matches the algorithm suite specification
         * and that the unencrypted data key is non-NULL.
         * See: cryptographic_materials.ts, `getUnencryptedDataKey`
         */
        needs(material.hasValidKey(), 'Unencrypted data key is invalid.');
        /* Postcondition: The WebCryptoEncryptionMaterial must contain at least 1 EncryptedDataKey. */
        needs(material.encryptedDataKeys.length, 'No EncryptedDataKeys: the ciphertext can never be decrypted.');
        return material;
    }
    async decryptMaterials({ suite, encryptedDataKeys, encryptionContext }) {
        const material = await this
            .keyring
            .onDecrypt(await this._initializeDecryptionMaterial(suite, encryptionContext), encryptedDataKeys.slice());
        /* Postcondition: The WebCryptoDecryptionMaterial must contain a valid dataKey.
         * See: cryptographic_materials.ts, `getUnencryptedDataKey` also verifies
         * that the unencrypted data key has not been manipulated,
         * that the data key matches the algorithm suite specification
         * and that the unencrypted data key is non-NULL.
         */
        needs(material.hasValidKey(), 'Unencrypted data key is invalid.');
        return material;
    }
    async _initializeEncryptionMaterial(suite, encryptionContext) {
        const { signatureCurve: namedCurve } = suite;
        /* Check for early return (Postcondition): The WebCryptoAlgorithmSuite specification must support a signatureCurve to generate a signing key. */
        if (!namedCurve)
            return new WebCryptoEncryptionMaterial(suite, encryptionContext);
        const backend = await getWebCryptoBackend();
        const subtle = getNonZeroByteBackend(backend);
        const webCryptoAlgorithm = { name: 'ECDSA', namedCurve };
        const extractable = false;
        const usages = ['sign'];
        const format = 'raw';
        const { publicKey, privateKey } = await subtle.generateKey(webCryptoAlgorithm, extractable, usages);
        const publicKeyBytes = await subtle.exportKey(format, publicKey);
        const compressPoint = SignatureKey.encodeCompressPoint(new Uint8Array(publicKeyBytes), suite);
        const signatureKey = new SignatureKey(privateKey, compressPoint, suite);
        return new WebCryptoEncryptionMaterial(suite, { ...encryptionContext, [ENCODED_SIGNER_KEY]: toBase64(compressPoint) })
            .setSignatureKey(signatureKey);
    }
    async _initializeDecryptionMaterial(suite, encryptionContext) {
        const { signatureCurve: namedCurve } = suite;
        /* Check for early return (Postcondition): The WebCryptoAlgorithmSuite specification must support a signatureCurve to extract a verification key. */
        if (!namedCurve)
            return new WebCryptoDecryptionMaterial(suite, encryptionContext);
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager If the algorithm suite specification requires a signatureCurve a context must exist. */
        if (!encryptionContext)
            throw new Error('Encryption context does not contain required public key.');
        const { [ENCODED_SIGNER_KEY]: compressPoint } = encryptionContext;
        /* Precondition: WebCryptoDefaultCryptographicMaterialsManager The context must contain the public key. */
        needs(compressPoint, 'Context does not contain required public key.');
        const backend = await getWebCryptoBackend();
        const subtle = getNonZeroByteBackend(backend);
        const webCryptoAlgorithm = { name: 'ECDSA', namedCurve };
        const extractable = false;
        const usages = ['verify'];
        const format = 'raw';
        const publicKeyBytes = VerificationKey.decodeCompressPoint(fromBase64(compressPoint), suite);
        const publicKey = await subtle.importKey(format, publicKeyBytes, webCryptoAlgorithm, extractable, usages);
        return new WebCryptoDecryptionMaterial(suite, encryptionContext)
            .setVerificationKey(new VerificationKey(publicKey, suite));
    }
}
immutableBaseClass(WebCryptoDefaultCryptographicMaterialsManager);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvd3Nlcl9jcnlwdG9ncmFwaGljX21hdGVyaWFsc19tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Jyb3dzZXJfY3J5cHRvZ3JhcGhpY19tYXRlcmlhbHNfbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUgsT0FBTyxFQUVpQyxxQ0FBcUM7QUFDM0UsdUJBQXVCLEVBQUUsMkJBQTJCLEVBQ3BELDJCQUEyQixFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQ2xFLGVBQWUsRUFBRSx3QkFBd0IsRUFBRSxrQkFBa0IsRUFDN0QsZ0JBQWdCLEVBQ2pCLE1BQU0saUNBQWlDLENBQUE7QUFFeEMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sdUJBQXVCLENBQUE7QUFDMUQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHFCQUFxQixFQUFFLE1BQU0sZ0NBQWdDLENBQUE7QUFDM0YsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQTtBQU9uRTs7OztHQUlHO0FBQ0gsTUFBTSxPQUFPLDZDQUE2QztJQUV4RCxZQUFhLE9BQXlCO1FBQ3BDLHdEQUF3RDtRQUN4RCxLQUFLLENBQUMsT0FBTyxZQUFZLGdCQUFnQixFQUFFLG1CQUFtQixDQUFDLENBQUE7UUFDL0QsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQTtJQUM1QyxDQUFDO0lBQ0QsS0FBSyxDQUFDLHNCQUFzQixDQUFFLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixFQUE4QjtRQUNwRixLQUFLLEdBQUcsS0FBSyxJQUFJLElBQUksdUJBQXVCLENBQUMsd0JBQXdCLENBQUMsZ0RBQWdELENBQUMsQ0FBQTtRQUV2SDs7Ozs7V0FLRztRQUNILEtBQUssQ0FBQyxDQUFDLGlCQUFpQixDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLG9D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
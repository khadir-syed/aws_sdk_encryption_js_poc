"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const material_management_browser_1 = require("@aws-crypto/material-management-browser");
const web_crypto_backend_1 = require("@aws-crypto/web-crypto-backend");
const raw_keyring_1 = require("@aws-crypto/raw-keyring");
const random_source_browser_1 = require("@aws-crypto/random-source-browser");
const get_import_options_1 = require("./get_import_options");
class RawRsaKeyringWebCrypto extends material_management_browser_1.KeyringWebCrypto {
    constructor(input) {
        super();
        this._rawOnEncrypt = raw_keyring_1._onEncrypt(random_source_browser_1.randomValuesOnly);
        this._onEncrypt = async (material) => {
            const _material = await this._rawOnEncrypt(material);
            return material_management_browser_1.importForWebCryptoEncryptionMaterial(_material);
        };
        /* onDecrypt does not need to import the CryptoKey, because this is handled in the unwrap operation.
         * Encrypt needs to have access to the unencrypted data key to encrypt with other keyrings
         * but once I have functional material no other decrypt operations need to be performed.
         */
        this._onDecrypt = raw_keyring_1._onDecrypt();
        const { publicKey, privateKey, keyName, keyNamespace } = input;
        /* Precondition: RsaKeyringWebCrypto needs either a public or a private key to operate. */
        material_management_browser_1.needs(publicKey || privateKey, 'No Key provided.');
        /* Precondition: RsaKeyringWebCrypto needs identifying information for encrypt and decrypt. */
        material_management_browser_1.needs(keyName && keyNamespace, 'Identifying information must be defined.');
        const wrappingAlgorithm = get_import_options_1.getWrappingAlgorithm(publicKey, privateKey);
        const _wrapKey = async (material) => {
            /* Precondition: I must have a publicKey to wrap. */
            if (!publicKey)
                throw new Error('No publicKey configured, encrypt not supported.');
            // The nonZero backend is used because some browsers support Subtle Crypto
            // but do not support Zero Byte AES-GCM. I want to use the native
            // browser implementation of wrapKey
            const subtle = web_crypto_backend_1.getNonZeroByteBackend(await web_crypto_backend_1.getWebCryptoBackend());
            /* Can not use importCryptoKey as `wrapKey` requires extractable = true
             * In web crypto `wrapKey` is a composition of `export` and `encrypt` and
             * so the cryptoKey must have `extractable = true`.
             */
            const extractable = true;
            const { encryption } = material.suite;
            const importFormat = 'jwk';
            const keyUsages = ['wrapKey']; // limit the use of this key (*not* decrypt, encrypt, deriveKey)
            const jwk = material_management_browser_1.bytes2JWK(material_management_browser_1.unwrapDataKey(material.getUnencryptedDataKey()));
            const cryptoKey = await subtle.importKey(importFormat, jwk, encryption, extractable, keyUsages);
            const wrapFormat = 'raw';
            const encryptedArrayBuffer = await subtle.wrapKey(wrapFormat, cryptoKey, publicKey, wrappingAlgorithm);
            // Can the extractable setting of cryptoKey be changed to false here?  If so, do it.
            const edk = new material_management_browser_1.EncryptedDataKey({
                providerId: keyNamespace,
                providerInfo: keyName,
                encryptedDataKey: new Uint8Array(encryptedArrayBuffer)
            });
            return material.addEncryptedDataKey(edk, material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY);
        };
        /* returns either an array of 1 CryptoKey or an array of both from MixedBackendCryptoKey e.g.
         * [privateKey] || [nonZeroByteCryptoKey, zeroByteCryptoKey]
         */
        const privateKeys = get_import_options_1.flattenMixedCryptoKey(privateKey);
        const _unwrapKey = async (material, edk) => {
            /* Precondition: I must have a privateKey to unwrap. */
            if (!privateKey)
                throw new Error('No privateKey configured, decrypt not supported.');
            const backend = await web_crypto_backend_1.getWebCryptoBackend();
            const { suite } = material;
            const trace = {
                keyName: this.keyName,
                keyNamespace: this.keyNamespace,
                flags: material_management_browser_1.KeyringTraceFlag.WRAPPING_KEY_DECRYPTED_DATA_KEY
            };
            const format = 'raw';
            const extractable = false;
            const algorithm = suite.kdf ? suite.kdf : suite.encryption;
            const keyUsages = [material_management_browser_1.keyUsageForMaterial(material)];
            const importArgs = [
                format,
                edk.encryptedDataKey,
                privateKeys[0],
                wrappingAlgorithm,
                algorithm,
                extractable,
                keyUsages
            ];
            /* This is superior to importForWebCryptoDecryptionMaterial.
             * Here I use `subtle.unwrap` and bring the unencrypted data key into the WebCrypto world
             * without ever exposing the unencrypted data key to JavaScript.
             */
            if (web_crypto_backend_1.isFullSupportWebCryptoBackend(backend)) {
                const cryptoKey = await backend.subtle.unwrapKey(...importArgs);
                return material.setCryptoKey(cryptoKey, trace);
            }
            else {
                const importZeroBackend = [...importArgs];
                importZeroBackend[2] = privateKeys[1];
                const mixedDataKey = await Promise.all([
                    backend.nonZeroByteSubtle.unwrapKey(...importArgs),
                    backend.zeroByteSubtle.unwrapKey(...importZeroBackend)
                ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({ nonZeroByteCryptoKey, zeroByteCryptoKey }));
                return material.setCryptoKey(mixedDataKey, trace);
            }
        };
        material_management_browser_1.readOnlyProperty(this, 'keyName', keyName);
        material_management_browser_1.readOnlyProperty(this, 'keyNamespace', keyNamespace);
        material_management_browser_1.readOnlyProperty(this, '_wrapKey', _wrapKey);
        material_management_browser_1.readOnlyProperty(this, '_unwrapKey', _unwrapKey);
    }
    _filter({ providerId, providerInfo }) {
        const { keyNamespace, keyName } = this;
        return providerId === keyNamespace && providerInfo.startsWith(keyName);
    }
    static async importPublicKey(publicKey) {
        const { wrappingAlgorithm, format, key } = get_import_options_1.getImportOptions(publicKey);
        const backend = await web_crypto_backend_1.getWebCryptoBackend();
        const subtle = web_crypto_backend_1.getNonZeroByteBackend(backend);
        return subtle.importKey(format, key, wrappingAlgorithm, false, ['wrapKey']);
    }
    static async importPrivateKey(privateKey) {
        const { wrappingAlgorithm, format, key } = get_import_options_1.getImportOptions(privateKey);
        const backend = await web_crypto_backend_1.getWebCryptoBackend();
        if (web_crypto_backend_1.isFullSupportWebCryptoBackend(backend)) {
            return backend.subtle.importKey(format, key, wrappingAlgorithm, false, ['unwrapKey']);
        }
        else {
            return Promise.all([
                backend.nonZeroByteSubtle.importKey(format, key, wrappingAlgorithm, false, ['unwrapKey']),
                backend.zeroByteSubtle.importKey(format, key, wrappingAlgorithm, false, ['unwrapKey'])
            ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({ nonZeroByteCryptoKey, zeroByteCryptoKey }));
        }
    }
}
exports.RawRsaKeyringWebCrypto = RawRsaKeyringWebCrypto;
material_management_browser_1.immutableClass(RawRsaKeyringWebCrypto);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3X3JzYV9rZXlyaW5nX3dlYl9jcnlwdG8uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcmF3X3JzYV9rZXlyaW5nX3dlYl9jcnlwdG8udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7O0dBYUc7O0FBRUgseUZBZ0JnRDtBQUVoRCx1RUFJdUM7QUFDdkMseURBS2dDO0FBQ2hDLDZFQUFvRTtBQUVwRSw2REFBb0c7QUFFcEcsTUFBYSxzQkFBdUIsU0FBUSw4Q0FBZ0I7SUFNMUQsWUFBYSxLQUFrQztRQUM3QyxLQUFLLEVBQUUsQ0FBQTtRQXVHVCxrQkFBYSxHQUFHLHdCQUFVLENBQWtELHdDQUFnQixDQUFDLENBQUE7UUFDN0YsZUFBVSxHQUFHLEtBQUssRUFBRSxRQUFxQyxFQUFFLEVBQUU7WUFDM0QsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1lBQ3BELE9BQU8sa0VBQW9DLENBQUMsU0FBUyxDQUFDLENBQUE7UUFDeEQsQ0FBQyxDQUFBO1FBRUQ7OztXQUdHO1FBQ0gsZUFBVSxHQUFHLHdCQUFVLEVBQW1ELENBQUE7UUEvR3hFLE1BQU0sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsR0FBRyxLQUFLLENBQUE7UUFDOUQsMEZBQTBGO1FBQzFGLG1DQUFLLENBQUMsU0FBUyxJQUFJLFVBQVUsRUFBRSxrQkFBa0IsQ0FBQyxDQUFBO1FBQ2xELDhGQUE4RjtRQUM5RixtQ0FBSyxDQUFDLE9BQU8sSUFBSSxZQUFZLEVBQUUsMENBQTBDLENBQUMsQ0FBQTtRQUUxRSxNQUFNLGlCQUFpQixHQUFHLHlDQUFvQixDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQTtRQUVyRSxNQUFNLFFBQVEsR0FBRyxLQUFLLEVBQUUsUUFBcUMsRUFBRSxFQUFFO1lBQy9ELG9EQUFvRDtZQUNwRCxJQUFJLENBQUMsU0FBUztnQkFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUE7WUFFbEYsMEVBQTBFO1lBQzFFLGlFQUFpRTtZQUNqRSxvQ0FBb0M7WUFDcEMsTUFBTSxNQUFNLEdBQUcsMENBQXFCLENBQUMsTUFBTSx3Q0FBbUIsRUFBRSxDQUFDLENBQUE7WUFDakU7OztlQUdHO1lBQ0gsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFBO1lBQ3hCLE1BQU0sRUFBRSxVQUFVLEVBQUUsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFBO1lBQ3JDLE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQTtZQUMxQixNQUFNLFNBQVMsR0FBZSxDQUFDLFNBQVMsQ0FBQyxDQUFBLENBQUMsZ0VBQWdFO1lBQzFHLE1BQU0sR0FBRyxHQUFHLHVDQUFTLENBQUMsMkNBQWEsQ0FBQyxRQUFRLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxDQUFDLENBQUE7WUFDdEUsTUFBTSxTQUFTLEdBQUcsTUFBTSxNQUFNLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQTtZQUUvRixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUE7WUFDeEIsTUFBTSxvQkFBb0IsR0FBRyxNQUFNLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsaUJBQWlCLENBQUMsQ0FBQTtZQUV0RyxvRkFBb0Y7WUFDcEYsTUFBTSxHQUFHLEdBQUcsSUFBSSw4Q0FBZ0IsQ0FBQztnQkFDL0IsVUFBVSxFQUFFLFlBQVk7Z0JBQ3hCLFlBQVksRUFBRSxPQUFPO2dCQUNyQixnQkFBZ0IsRUFBRSxJQUFJLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQzthQUN2RCxDQUFDLENBQUE7WUFFRixPQUFPLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsOENBQWdCLENBQUMsK0JBQStCLENBQUMsQ0FBQTtRQUM1RixDQUFDLENBQUE7UUFFRDs7V0FFRztRQUNILE1BQU0sV0FBVyxHQUFHLDBDQUFxQixDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBRXJELE1BQU0sVUFBVSxHQUFHLEtBQUssRUFBRSxRQUFxQyxFQUFFLEdBQXFCLEVBQUUsRUFBRTtZQUN4Rix1REFBdUQ7WUFDdkQsSUFBSSxDQUFDLFVBQVU7Z0JBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxrREFBa0QsQ0FBQyxDQUFBO1lBQ3BGLE1BQU0sT0FBTyxHQUFHLE1BQU0sd0NBQW1CLEVBQUUsQ0FBQTtZQUMzQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsUUFBUSxDQUFBO1lBRTFCLE1BQU0sS0FBSyxHQUFpQjtnQkFDMUIsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO2dCQUNyQixZQUFZLEVBQUUsSUFBSSxDQUFDLFlBQVk7Z0JBQy9CLEtBQUssRUFBRSw4Q0FBZ0IsQ0FBQywrQkFBK0I7YUFDeEQsQ0FBQTtZQUVELE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQTtZQUNwQixNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUE7WUFDekIsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQTtZQUMxRCxNQUFNLFNBQVMsR0FBRyxDQUFDLGlEQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUE7WUFFakQsTUFBTSxVQUFVLEdBQXlDO2dCQUN2RCxNQUFNO2dCQUNOLEdBQUcsQ0FBQyxnQkFBZ0I7Z0JBQ3BCLFdBQVcsQ0FBQyxDQUFDLENBQUM7Z0JBQ2QsaUJBQWlCO2dCQUNqQixTQUFTO2dCQUNULFdBQVc7Z0JBQ1gsU0FBUzthQUNWLENBQUE7WUFFRDs7O2VBR0c7WUFDSCxJQUFJLGtEQUE2QixDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUMxQyxNQUFNLFNBQVMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUE7Z0JBQy9ELE9BQU8sUUFBUSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUE7YUFDL0M7aUJBQU07Z0JBQ0wsTUFBTSxpQkFBaUIsR0FBMEMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFBO2dCQUNoRixpQkFBaUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUE7Z0JBQ3JDLE1BQU0sWUFBWSxHQUEwQixNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUM7b0JBQzVELE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxVQUFVLENBQUM7b0JBQ2xELE9BQU8sQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUcsaUJBQWlCLENBQUM7aUJBQ3ZELENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLG9CQUFvQixFQUFFLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxvQkFBb0IsRUFBRSxpQkFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQTtnQkFDckcsT0FBTyxRQUFRLENBQUMsWUFBWSxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQTthQUNsRDtRQUNILENBQUMsQ0FBQTtRQUVELDhDQUFnQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUE7UUFDMUMsOENBQWdCLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRSxZQUFZLENBQUMsQ0FBQTtRQUNwRCw4Q0FBZ0IsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFBO1FBQzVDLDhDQUFnQixDQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUE7SUFDbEQsQ0FBQztJQUVELE9BQU8sQ0FBRSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQW9CO1FBQ3JELE1BQU0sRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFBO1FBQ3RDLE9BQU8sVUFBVSxLQUFLLFlBQVksSUFBSSxZQUFZLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFBO0lBQ3hFLENBQUM7SUFjRCxNQUFNLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBRSxTQUEyQjtRQUN2RCxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLHFDQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFBO1FBQ3RFLE1BQU0sT0FBTyxHQUFHLE1BQU0sd0NBQW1CLEVBQUUsQ0FBQTtRQUMzQyxNQUFNLE1BQU0sR0FBRywwQ0FBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUM3QyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxpQkFBaUIsRUFBRSxLQUFLLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFBO0lBQzdFLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFFLFVBQTRCO1FBQ3pELE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcscUNBQWdCLENBQUMsVUFBVSxDQUFDLENBQUE7UUFDdkUsTUFBTSxPQUFPLEdBQUcsTUFBTSx3Q0FBbUIsRUFBRSxDQUFBO1FBRTNDLElBQUksa0RBQTZCLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDMUMsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUE7U0FDdEY7YUFBTTtZQUNMLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQztnQkFDakIsT0FBTyxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUN6RixPQUFPLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ3ZGLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLG9CQUFvQixFQUFFLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxvQkFBb0IsRUFBRSxpQkFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQTtTQUN0RztJQUNILENBQUM7Q0FDRjtBQTlJRCx3REE4SUM7QUFDRCw0Q0FBYyxDQUFDLHNCQUFzQixDQUFDLENBQUEifQ==
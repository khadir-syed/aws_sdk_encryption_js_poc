/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { RsaPadding, JsonWebKeyRsaAlg, RsaHash } from './types';
import { // eslint-disable-line no-unused-vars
needs, isCryptoKey } from '@aws-crypto/material-management-browser';
const OAEP_SHA1_MFG1 = { name: 'RSA-OAEP', hash: { name: 'SHA-1' } };
Object.freeze(OAEP_SHA1_MFG1);
Object.freeze(OAEP_SHA1_MFG1.hash);
const OAEP_SHA256_MFG1 = { name: 'RSA-OAEP', hash: { name: 'SHA-256' } };
Object.freeze(OAEP_SHA256_MFG1);
Object.freeze(OAEP_SHA256_MFG1.hash);
const OAEP_SHA384_MFG1 = { name: 'RSA-OAEP', hash: { name: 'SHA-384' } };
Object.freeze(OAEP_SHA384_MFG1);
Object.freeze(OAEP_SHA384_MFG1.hash);
const OAEP_SHA512_MFG1 = { name: 'RSA-OAEP', hash: { name: 'SHA-512' } };
Object.freeze(OAEP_SHA512_MFG1);
Object.freeze(OAEP_SHA512_MFG1.hash);
const JsonWebKeyMap = Object.freeze({
    [JsonWebKeyRsaAlg['RSA-OAEP']]: OAEP_SHA1_MFG1,
    [JsonWebKeyRsaAlg['RSA-OAEP-256']]: OAEP_SHA256_MFG1,
    [JsonWebKeyRsaAlg['RSA-OAEP-384']]: OAEP_SHA384_MFG1,
    [JsonWebKeyRsaAlg['RSA-OAEP-512']]: OAEP_SHA512_MFG1
});
const RsaPaddingMap = Object.freeze({
    [RsaPadding.OAEP_SHA1_MFG1]: OAEP_SHA1_MFG1,
    [RsaPadding.OAEP_SHA256_MFG1]: OAEP_SHA256_MFG1,
    [RsaPadding.OAEP_SHA384_MFG1]: OAEP_SHA384_MFG1,
    [RsaPadding.OAEP_SHA512_MFG1]: OAEP_SHA512_MFG1
});
export function getImportOptions(keyInfo) {
    const { alg } = keyInfo;
    const { padding } = keyInfo;
    if (JsonWebKeyMap[alg]) {
        return {
            format: 'jwk',
            key: keyInfo,
            wrappingAlgorithm: JsonWebKeyMap[alg]
        };
    }
    else if (RsaPaddingMap[padding]) {
        const { format, key } = keyInfo;
        return {
            format,
            key,
            wrappingAlgorithm: RsaPaddingMap[padding]
        };
    }
    throw new Error('Unsupported RsaImportableKey');
}
export function getWrappingAlgorithm(publicKey, privateKey) {
    const privateKeys = flattenMixedCryptoKey(privateKey);
    if (publicKey && privateKeys.length) {
        return verify(...[publicKey, ...privateKeys].map(extract));
    }
    else if (publicKey) {
        return verify(extract(publicKey));
    }
    else if (privateKeys.length) {
        return verify(...privateKeys.map(extract));
    }
    throw new Error('No Key provided.');
}
export function extract(key) {
    const { algorithm } = key;
    // @ts-ignore
    const { name, hash } = algorithm;
    return { name: name, hash };
}
export function verify(...args) {
    const [wrappingAlgorithm, ...rest] = args;
    /* Precondition: Need at least 1 algorithm to verify. */
    needs(wrappingAlgorithm, 'Can not verify an empty set of algorithms.');
    const { name, hash } = wrappingAlgorithm;
    /* Precondition: The wrappingAlgorithm name must be a supported value. */
    needs(JsonWebKeyRsaAlg[name], 'Algorithm name is not supported.');
    /* Precondition: The hash name must be a supported value. */
    needs(hash && RsaHash[hash.name], 'Hash name is not supported.');
    /* Check for early return (Postcondition): Only 1 wrappingAlgorithm is clearly valid. */
    if (!rest.length)
        return wrappingAlgorithm;
    /* Precondition: All keys must have the same wrappingAlgorithm. */
    needs(rest.every(equalWrappingAlgorithm), 'Not all RSA keys have the same wrappingAlgorithm.');
    return wrappingAlgorithm;
    function equalWrappingAlgorithm(algorithm) {
        return algorithm.name === name &&
            algorithm.hash &&
            algorithm.hash.name === hash.name;
    }
}
export function flattenMixedCryptoKey(key) {
    /* Check for early return (Postcondition): empty inputs should return an empty array. */
    if (!key)
        return [];
    if (isCryptoKey(key))
        return [key];
    const { nonZeroByteCryptoKey, zeroByteCryptoKey } = key;
    const keys = [nonZeroByteCryptoKey, zeroByteCryptoKey];
    /* Postcondition: Not all keys are CryptoKeys. */
    needs(keys.every(isCryptoKey), 'Not all keys are CryptoKeys.');
    return keys;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0X2ltcG9ydF9vcHRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2dldF9pbXBvcnRfb3B0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUgsT0FBTyxFQUNMLFVBQVUsRUFDVixnQkFBZ0IsRUFDaEIsT0FBTyxFQUtSLE1BQU0sU0FBUyxDQUFBO0FBQ2hCLE9BQU8sRUFDa0IscUNBQXFDO0FBQzVELEtBQUssRUFDTCxXQUFXLEVBQ1osTUFBTSx5Q0FBeUMsQ0FBQTtBQUdoRCxNQUFNLGNBQWMsR0FBNEIsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsRUFBRSxDQUFBO0FBQzdGLE1BQU0sQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUE7QUFDN0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUE7QUFFbEMsTUFBTSxnQkFBZ0IsR0FBNEIsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUFBO0FBQ2pHLE1BQU0sQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtBQUMvQixNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFBO0FBRXBDLE1BQU0sZ0JBQWdCLEdBQTRCLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQTtBQUNqRyxNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUE7QUFDL0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUVwQyxNQUFNLGdCQUFnQixHQUE0QixFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxF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
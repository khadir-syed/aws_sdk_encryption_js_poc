/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { immutableClass, readOnlyProperty } from './immutable_class';
import { // eslint-disable-line no-unused-vars
KeyringNode, KeyringWebCrypto } from './keyring';
import { needs } from './needs';
export class MultiKeyringNode extends KeyringNode {
    constructor(input) {
        super();
        this._onEncrypt = buildPrivateOnEncrypt();
        this._onDecrypt = buildPrivateOnDecrypt();
        decorateProperties(this, KeyringNode, input);
    }
}
immutableClass(MultiKeyringNode);
export class MultiKeyringWebCrypto extends KeyringWebCrypto {
    constructor(input) {
        super();
        this._onEncrypt = buildPrivateOnEncrypt();
        this._onDecrypt = buildPrivateOnDecrypt();
        decorateProperties(this, KeyringWebCrypto, input);
    }
}
immutableClass(MultiKeyringWebCrypto);
function decorateProperties(obj, BaseKeyring, { generator, children = [] }) {
    /* Precondition: MultiKeyring must have keyrings. */
    needs(generator || children.length, 'Noop MultiKeyring is not supported.');
    /* Precondition: generator must be a Keyring. */
    needs(!!generator === generator instanceof BaseKeyring, 'Generator must be a Keyring');
    /* Precondition: All children must be Keyrings. */
    needs(children.every(kr => kr instanceof BaseKeyring), 'Child must be a Keyring');
    readOnlyProperty(obj, 'children', Object.freeze(children.slice()));
    readOnlyProperty(obj, 'generator', generator);
}
function buildPrivateOnEncrypt() {
    return async function _onEncrypt(material) {
        /* Precondition: Only Keyrings explicitly designated as generators can generate material.
         * Technically, the precondition below will handle this.
         * Since if I do not have an unencrypted data key,
         * and I do not have a generator,
         * then generated.hasUnencryptedDataKey === false will throw.
         * But this is a much more meaningful error.
         */
        needs(!material.hasUnencryptedDataKey ? this.generator : true, 'Only Keyrings explicitly designated as generators can generate material.');
        const generated = this.generator
            ? await this.generator.onEncrypt(material)
            : material;
        /* Precondition: A Generator Keyring *must* ensure generated material. */
        needs(generated.hasUnencryptedDataKey, 'Generator Keyring has not generated material.');
        /* By default this is a serial operation.  A keyring _may_ perform an expensive operation
         * or create resource constraints such that encrypting with multiple keyrings could
         * fail in unexpected ways.
         * Additionally, "downstream" keyrings may make choices about the EncryptedDataKeys they
         * append based on already appended EDK's.
         */
        for (const keyring of this.children) {
            await keyring.onEncrypt(generated);
        }
        // Keyrings are required to not create new EncryptionMaterial instances, but
        // only append EncryptedDataKey.  Therefore the generated material has all
        // the data I want.
        return generated;
    };
}
function buildPrivateOnDecrypt() {
    return async function _onDecrypt(material, encryptedDataKeys) {
        const children = this.children.slice();
        if (this.generator)
            children.unshift(this.generator);
        let childKeyringErrors = [];
        for (const keyring of children) {
            /* Check for early return (Postcondition): Do not attempt to decrypt once I have a valid key. */
            if (material.hasValidKey())
                return material;
            try {
                await keyring.onDecrypt(material, encryptedDataKeys);
            }
            catch (e) {
                /* Failures onDecrypt should not short-circuit the process
                 * If the caller does not have access they may have access
                 * through another Keyring.
                 */
                childKeyringErrors.push(e);
            }
        }
        /* Postcondition: A child keyring must provide a valid data key or no child keyring must have raised an error.
         * If I have a data key,
         * decrypt errors can be ignored.
         * However, if I was unable to decrypt a data key AND I have errors,
         * these errors should bubble up.
         * Otherwise, the only error customers will see is that
         * the material does not have an unencrypted data key.
         * So I return a concatenated Error message
         */
        needs(material.hasValidKey() || (!material.hasValidKey() && !childKeyringErrors.length), childKeyringErrors
            .reduce((m, e, i) => `${m} Error #${i + 1} \n ${e.stack} \n`, 'Unable to decrypt data key and one or more child keyrings had an error. \n '));
        return material;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibXVsdGlfa2V5cmluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tdWx0aV9rZXlyaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFFSCxPQUFPLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUE7QUFDcEUsT0FBTyxFQUNJLHFDQUFxQztBQUM5QyxXQUFXLEVBQ1gsZ0JBQWdCLEVBQ2pCLE1BQU0sV0FBVyxDQUFBO0FBRWxCLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFLL0IsTUFBTSxPQUFPLGdCQUFpQixTQUFRLFdBQVc7SUFHL0MsWUFBYSxLQUE0QztRQUN2RCxLQUFLLEVBQUUsQ0FBQTtRQUdULGVBQVUsR0FBRyxxQkFBcUIsRUFBc0IsQ0FBQTtRQUN4RCxlQUFVLEdBQUcscUJBQXFCLEVBQXNCLENBQUE7UUFIdEQsa0JBQWtCLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsQ0FBQTtJQUM5QyxDQUFDO0NBR0Y7QUFDRCxjQUFjLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtBQUVoQyxNQUFNLE9BQU8scUJBQXNCLFNBQVEsZ0JBQWdCO0lBSXpELFlBQWEsS0FBaUQ7UUFDNUQsS0FBSyxFQUFFLENBQUE7UUFHVCxlQUFVLEdBQUcscUJBQXFCLEVBQTJCLENBQUE7UUFDN0QsZUFBVSxHQUFHLHFCQUFxQixFQUEyQixDQUFBO1FBSDNELGtCQUFrQixDQUFDLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLENBQUMsQ0FBQTtJQUNuRCxDQUFDO0NBR0Y7QUFDRCxjQUFjLENBQUMscUJBQXFCLENBQUMsQ0FBQTtBQUVyQyxTQUFTLGtCQUFrQixDQUN6QixHQUFxQixFQUNyQixXQUFnQixFQUNoQixFQUFFLFNBQVMsRUFBRSxRQUFRLEdBQUcsRUFBRSxFQUF3QjtJQUVsRCxvREFBb0Q7SUFDcEQsS0FBSyxDQUFDLFNB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
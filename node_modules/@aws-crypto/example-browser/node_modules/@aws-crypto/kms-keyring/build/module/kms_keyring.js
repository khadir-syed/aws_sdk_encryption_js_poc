/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { needs, // eslint-disable-line no-unused-vars
KeyringTraceFlag, // eslint-disable-line no-unused-vars
immutableClass, readOnlyProperty, unwrapDataKey } from '@aws-crypto/material-management';
import { KMS_PROVIDER_ID, generateDataKey, encrypt, decrypt, kmsResponseToEncryptedDataKey } from './helpers';
import { regionFromKmsKeyArn } from './region_from_kms_key_arn';
export function KmsKeyringClass(BaseKeyring) {
    class KmsKeyring extends BaseKeyring {
        constructor({ clientProvider, generatorKeyId, keyIds = [], grantTokens, discovery }) {
            super();
            /* Precondition: This is an abstract class. (But TypeScript does not have a clean way to model this) */
            needs(this.constructor !== KmsKeyring, 'new KmsKeyring is not allowed');
            /* Precondition: A noop KmsKeyring is not allowed. */
            needs(!(!discovery && !generatorKeyId && !keyIds.length), 'Noop keyring is not allowed: Set a keyId or discovery');
            /* Precondition: A keyring can be either a Discovery or have keyIds configured. */
            needs(!(discovery && (generatorKeyId || keyIds.length)), 'A keyring can be either a Discovery or have keyIds configured.');
            /* Precondition: All KMS key arns must be valid. */
            needs(!generatorKeyId || !!regionFromKmsKeyArn(generatorKeyId), 'Malformed arn.');
            needs(keyIds.every(keyarn => !!regionFromKmsKeyArn(keyarn)), 'Malformed arn.');
            /* Precondition: clientProvider needs to be a callable function. */
            needs(typeof clientProvider === 'function', 'Missing clientProvider');
            readOnlyProperty(this, 'clientProvider', clientProvider);
            readOnlyProperty(this, 'keyIds', Object.freeze(keyIds.slice()));
            readOnlyProperty(this, 'generatorKeyId', generatorKeyId);
            readOnlyProperty(this, 'grantTokens', grantTokens);
            readOnlyProperty(this, 'isDiscovery', !!discovery);
        }
        /* Keyrings *must* preserve the order of EDK's.  The generatorKeyId is the first on this list. */
        async _onEncrypt(material) {
            /* Check for early return (Postcondition): Discovery Keyrings do not encrypt. */
            if (this.isDiscovery)
                return material;
            const keyIds = this.keyIds.slice();
            const { clientProvider, generatorKeyId, grantTokens } = this;
            if (generatorKeyId && !material.hasUnencryptedDataKey) {
                const dataKey = await generateDataKey(clientProvider, material.suite.keyLengthBytes, generatorKeyId, material.encryptionContext, grantTokens);
                /* Precondition: A generatorKeyId must generate if we do not have an unencrypted data key.
                * Client supplier is allowed to return undefined if, for example, user wants to exclude particular
                * regions. But if we are here it means that user configured keyring with a KMS key that was
                * incompatible with the client supplier in use.
                */
                if (!dataKey)
                    throw new Error('Generator KMS key did not generate a data key');
                const flags = KeyringTraceFlag.WRAPPING_KEY_GENERATED_DATA_KEY |
                    KeyringTraceFlag.WRAPPING_KEY_SIGNED_ENC_CTX |
                    KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY;
                const trace = { keyNamespace: KMS_PROVIDER_ID, keyName: dataKey.KeyId, flags };
                material
                    /* Postcondition: The generated unencryptedDataKey length must match the algorithm specification.
                    * See cryptographic_materials as setUnencryptedDataKey will throw in this case.
                    */
                    .setUnencryptedDataKey(dataKey.Plaintext, trace)
                    .addEncryptedDataKey(kmsResponseToEncryptedDataKey(dataKey), KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY | KeyringTraceFlag.WRAPPING_KEY_SIGNED_ENC_CTX);
            }
            else if (generatorKeyId) {
                keyIds.unshift(generatorKeyId);
            }
            /* Precondition: If a generator does not exist, an unencryptedDataKey *must* already exist.
            * Furthermore *only* CMK's explicitly designated as generators can generate data keys.
            * See cryptographic_materials as getUnencryptedDataKey will throw in this case.
            */
            const unencryptedDataKey = unwrapDataKey(material.getUnencryptedDataKey());
            const flags = KeyringTraceFlag.WRAPPING_KEY_ENCRYPTED_DATA_KEY | KeyringTraceFlag.WRAPPING_KEY_SIGNED_ENC_CTX;
            for (const kmsKey of keyIds) {
                const kmsEDK = await encrypt(clientProvider, unencryptedDataKey, kmsKey, material.encryptionContext, grantTokens);
                /* clientProvider may not return a client, in this case there is not an EDK to add */
                if (kmsEDK)
                    material.addEncryptedDataKey(kmsResponseToEncryptedDataKey(kmsEDK), flags);
            }
            return material;
        }
        async _onDecrypt(material, encryptedDataKeys) {
            const keyIds = this.keyIds.slice();
            const { clientProvider, generatorKeyId, grantTokens } = this;
            if (generatorKeyId)
                keyIds.unshift(generatorKeyId);
            /* If there are no key IDs in the list, keyring is in "discovery" mode and will attempt KMS calls with
            * every ARN it comes across in the message. If there are key IDs in the list, it will cross check the
            * ARN it reads with that list before attempting KMS calls. Note that if caller provided key IDs in
            * anything other than a CMK ARN format, the Encryption SDK will not attempt to decrypt those data keys, because
            * the EDK data format always specifies the CMK with the full (non-alias) ARN.
            */
            const decryptableEDKs = encryptedDataKeys
                .filter(({ providerId, providerInfo }) => {
                if (providerId !== KMS_PROVIDER_ID)
                    return false;
                /* Discovery keyrings can not have keyIds configured,
                 * and non-discovery keyrings must have keyIds configured.
                 */
                return this.isDiscovery || keyIds.includes(providerInfo);
            });
            let cmkErrors = [];
            for (const edk of decryptableEDKs) {
                let dataKey = false;
                try {
                    dataKey = await decrypt(clientProvider, edk, material.encryptionContext, grantTokens);
                }
                catch (e) {
                    /* Failures onDecrypt should not short-circuit the process
                     * If the caller does not have access they may have access
                     * through another Keyring.
                     */
                    cmkErrors.push(e);
                }
                /* Check for early return (Postcondition): clientProvider may not return a client. */
                if (!dataKey)
                    continue;
                /* Postcondition: The KeyId from KMS must match the encoded KeyID. */
                needs(dataKey.KeyId === edk.providerInfo, 'KMS Decryption key does not match serialized provider.');
                const flags = KeyringTraceFlag.WRAPPING_KEY_DECRYPTED_DATA_KEY | KeyringTraceFlag.WRAPPING_KEY_VERIFIED_ENC_CTX;
                const trace = { keyNamespace: KMS_PROVIDER_ID, keyName: dataKey.KeyId, flags };
                /* Postcondition: The decrypted unencryptedDataKey length must match the algorithm specification.
                  * See cryptographic_materials as setUnencryptedDataKey will throw in this case.
                  */
                material.setUnencryptedDataKey(dataKey.Plaintext, trace);
                return material;
            }
            /* Postcondition: A CMK must provide a valid data key or KMS must not have raised any errors.
             * If I have a data key,
             * decrypt errors can be ignored.
             * However, if I was unable to decrypt a data key AND I have errors,
             * these errors should bubble up.
             * Otherwise, the only error customers will see is that
             * the material does not have an unencrypted data key.
             * So I return a concatenated Error message
             */
            needs(material.hasValidKey() || (!material.hasValidKey() && !cmkErrors.length), cmkErrors
                .reduce((m, e, i) => `${m} Error #${i + 1} \n ${e.stack} \n`, 'Unable to decrypt data key and one or more KMS CMKs had an error. \n '));
            return material;
        }
    }
    immutableClass(KmsKeyring);
    return KmsKeyring;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia21zX2tleXJpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMva21zX2tleXJpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7R0FhRztBQU9ILE9BQU8sRUFDTCxLQUFLLEVBS1MscUNBQXFDO0FBQ25ELGdCQUFnQixFQUNFLHFDQUFxQztBQUN2RCxjQUFjLEVBQ2QsZ0JBQWdCLEVBQ2hCLGFBQWEsRUFDZCxNQUFNLGlDQUFpQyxDQUFBO0FBQ3hDLE9BQU8sRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxXQUFXLENBQUE7QUFDN0csT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sMkJBQTJCLENBQUE7QUE0Qi9ELE1BQU0sVUFBVSxlQUFlLENBQzdCLFdBQW9DO0lBRXBDLE1BQU0sVUFBVyxTQUFRLFdBQVc7UUFPbEMsWUFBYSxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsTUFBTSxHQUFHLEVBQUUsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUEyQjtZQUMzRyxLQUFLLEVBQUUsQ0FBQTtZQUNQLHVHQUF1RztZQUN2RyxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsS0FBSyxVQUFVLEVBQUUsK0JBQStCLENBQUMsQ0FBQTtZQUN2RSxxREFBcUQ7WUFDckQsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFBSSxDQUFDLGNBQWMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSx1REFBdUQsQ0FBQyxDQUFBO1lBQ2xILGtGQUFrRjtZQUNsRixLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsSUFBSSxDQUFDLGNBQWMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxnRUFBZ0UsQ0FBQyxDQUFBO1lBQzFILG1EQUFtRDtZQUNuRCxLQUFLLENBQUMsQ0FBQyxjQUFjLElBQUksQ0FBQyxDQUFDLG1CQUFtQixD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
"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const material_management_browser_1 = require("@aws-crypto/material-management-browser");
const OAEP_SHA1_MFG1 = { name: 'RSA-OAEP', hash: { name: 'SHA-1' } };
Object.freeze(OAEP_SHA1_MFG1);
Object.freeze(OAEP_SHA1_MFG1.hash);
const OAEP_SHA256_MFG1 = { name: 'RSA-OAEP', hash: { name: 'SHA-256' } };
Object.freeze(OAEP_SHA256_MFG1);
Object.freeze(OAEP_SHA256_MFG1.hash);
const OAEP_SHA384_MFG1 = { name: 'RSA-OAEP', hash: { name: 'SHA-384' } };
Object.freeze(OAEP_SHA384_MFG1);
Object.freeze(OAEP_SHA384_MFG1.hash);
const OAEP_SHA512_MFG1 = { name: 'RSA-OAEP', hash: { name: 'SHA-512' } };
Object.freeze(OAEP_SHA512_MFG1);
Object.freeze(OAEP_SHA512_MFG1.hash);
const JsonWebKeyMap = Object.freeze({
    [types_1.JsonWebKeyRsaAlg['RSA-OAEP']]: OAEP_SHA1_MFG1,
    [types_1.JsonWebKeyRsaAlg['RSA-OAEP-256']]: OAEP_SHA256_MFG1,
    [types_1.JsonWebKeyRsaAlg['RSA-OAEP-384']]: OAEP_SHA384_MFG1,
    [types_1.JsonWebKeyRsaAlg['RSA-OAEP-512']]: OAEP_SHA512_MFG1
});
const RsaPaddingMap = Object.freeze({
    [types_1.RsaPadding.OAEP_SHA1_MFG1]: OAEP_SHA1_MFG1,
    [types_1.RsaPadding.OAEP_SHA256_MFG1]: OAEP_SHA256_MFG1,
    [types_1.RsaPadding.OAEP_SHA384_MFG1]: OAEP_SHA384_MFG1,
    [types_1.RsaPadding.OAEP_SHA512_MFG1]: OAEP_SHA512_MFG1
});
function getImportOptions(keyInfo) {
    const { alg } = keyInfo;
    const { padding } = keyInfo;
    if (JsonWebKeyMap[alg]) {
        return {
            format: 'jwk',
            key: keyInfo,
            wrappingAlgorithm: JsonWebKeyMap[alg]
        };
    }
    else if (RsaPaddingMap[padding]) {
        const { format, key } = keyInfo;
        return {
            format,
            key,
            wrappingAlgorithm: RsaPaddingMap[padding]
        };
    }
    throw new Error('Unsupported RsaImportableKey');
}
exports.getImportOptions = getImportOptions;
function getWrappingAlgorithm(publicKey, privateKey) {
    const privateKeys = flattenMixedCryptoKey(privateKey);
    if (publicKey && privateKeys.length) {
        return verify(...[publicKey, ...privateKeys].map(extract));
    }
    else if (publicKey) {
        return verify(extract(publicKey));
    }
    else if (privateKeys.length) {
        return verify(...privateKeys.map(extract));
    }
    throw new Error('No Key provided.');
}
exports.getWrappingAlgorithm = getWrappingAlgorithm;
function extract(key) {
    const { algorithm } = key;
    // @ts-ignore
    const { name, hash } = algorithm;
    return { name: name, hash };
}
exports.extract = extract;
function verify(...args) {
    const [wrappingAlgorithm, ...rest] = args;
    /* Precondition: Need at least 1 algorithm to verify. */
    material_management_browser_1.needs(wrappingAlgorithm, 'Can not verify an empty set of algorithms.');
    const { name, hash } = wrappingAlgorithm;
    /* Precondition: The wrappingAlgorithm name must be a supported value. */
    material_management_browser_1.needs(types_1.JsonWebKeyRsaAlg[name], 'Algorithm name is not supported.');
    /* Precondition: The hash name must be a supported value. */
    material_management_browser_1.needs(hash && types_1.RsaHash[hash.name], 'Hash name is not supported.');
    /* Check for early return (Postcondition): Only 1 wrappingAlgorithm is clearly valid. */
    if (!rest.length)
        return wrappingAlgorithm;
    /* Precondition: All keys must have the same wrappingAlgorithm. */
    material_management_browser_1.needs(rest.every(equalWrappingAlgorithm), 'Not all RSA keys have the same wrappingAlgorithm.');
    return wrappingAlgorithm;
    function equalWrappingAlgorithm(algorithm) {
        return algorithm.name === name &&
            algorithm.hash &&
            algorithm.hash.name === hash.name;
    }
}
exports.verify = verify;
function flattenMixedCryptoKey(key) {
    /* Check for early return (Postcondition): empty inputs should return an empty array. */
    if (!key)
        return [];
    if (material_management_browser_1.isCryptoKey(key))
        return [key];
    const { nonZeroByteCryptoKey, zeroByteCryptoKey } = key;
    const keys = [nonZeroByteCryptoKey, zeroByteCryptoKey];
    /* Postcondition: Not all keys are CryptoKeys. */
    material_management_browser_1.needs(keys.every(material_management_browser_1.isCryptoKey), 'Not all keys are CryptoKeys.');
    return keys;
}
exports.flattenMixedCryptoKey = flattenMixedCryptoKey;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0X2ltcG9ydF9vcHRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2dldF9pbXBvcnRfb3B0aW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7R0FhRzs7QUFFSCxtQ0FRZ0I7QUFDaEIseUZBSWdEO0FBR2hELE1BQU0sY0FBYyxHQUE0QixFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxFQUFFLENBQUE7QUFDN0YsTUFBTSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQTtBQUM3QixNQUFNLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQTtBQUVsQyxNQUFNLGdCQUFnQixHQUE0QixFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxFQUFFLENBQUE7QUFDakcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBO0FBQy9CLE1BQU0sQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUE7QUFFcEMsTUFBTSxnQkFBZ0IsR0FBNEIsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUFBO0FBQ2pHLE1BQU0sQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtBQUMvQixNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFBO0FBRXBDLE1BQU0sZ0JBQWdCLEdBQTRCLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQTtBQUNqRyxNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUE7QUFDL0IsTUFBTSxDQUFDLE1BQU0s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
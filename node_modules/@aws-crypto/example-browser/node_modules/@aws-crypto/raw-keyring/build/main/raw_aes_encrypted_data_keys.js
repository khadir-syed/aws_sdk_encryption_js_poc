"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* For raw AES keyrings the required wrapping information is stored in an EncryptedDataKey.
  * KeyNamespace (identifies the keyring "class"),
  * KeyName (identifies this specific keyring, like a KMS CMK ARN)
  *
  * {
  *   providerId: KeyNamespace
  *   providerInfo: utf8Encode(KeyName + TagLengthBits uInt32BE + IVLength uInt32BE + iv)
  *   encryptedDataKey: wrapped key + authTag
  * }
  *
  * The AAD (encryption context) is the same as the message.
  */
const serialize_1 = require("@aws-crypto/serialize");
const material_management_1 = require("@aws-crypto/material-management");
function rawAesEncryptedDataKeyFactory(toUtf8, fromUtf8) {
    return { rawAesEncryptedDataKey };
    function rawAesEncryptedDataKey(keyNamespace, keyName, iv, ciphertext, authTag) {
        const ivLength = iv.byteLength;
        const authTagBitLength = authTag.byteLength * 8;
        const encryptedDataKey = serialize_1.concatBuffers(ciphertext, authTag);
        const providerId = keyNamespace;
        const rawInfo = serialize_1.concatBuffers(fromUtf8(keyName), serialize_1.uInt32BE(authTagBitLength), serialize_1.uInt32BE(ivLength), iv);
        const providerInfo = toUtf8(rawInfo);
        return new material_management_1.EncryptedDataKey({ encryptedDataKey, providerId, providerInfo, rawInfo });
    }
}
exports.rawAesEncryptedDataKeyFactory = rawAesEncryptedDataKeyFactory;
function rawAesEncryptedPartsFactory(fromUtf8) {
    return { rawAesEncryptedParts };
    function rawAesEncryptedParts(suite, keyName, { encryptedDataKey, rawInfo }) {
        /* Precondition: rawInfo must be a Uint8Array. */
        if (!(rawInfo instanceof Uint8Array))
            throw new Error('Malformed Encrypted Data Key.');
        // see above for format, slice off the "string part"
        rawInfo = rawInfo.slice(fromUtf8(keyName).byteLength);
        /* Uint8Array is a view on top of the underlying ArrayBuffer.
          * This means that raw underlying memory stored in the ArrayBuffer
          * may be larger than the Uint8Array.  This is especially true of
          * the Node.js Buffer object.  The offset and length *must* be
          * passed to the DataView otherwise I will get unexpected results.
          */
        const dataView = new DataView(rawInfo.buffer, rawInfo.byteOffset, rawInfo.byteLength);
        /* See above:
          * uInt32BE(authTagBitLength),uInt32BE(ivLength), iv
          */
        const tagLengthBits = dataView.getUint32(0, false); // big endian
        const ivLength = dataView.getUint32(4, false); // big endian
        /* Precondition: The ivLength must match the algorith suite specification. */
        material_management_1.needs(ivLength === suite.ivLength, 'Malformed providerInfo');
        /* Precondition: The tagLength must match the algorith suite specification. */
        material_management_1.needs(tagLengthBits === suite.tagLength, 'Malformed providerInfo');
        /* Precondition: The byteLength of rawInfo should match the encoded length. */
        material_management_1.needs(rawInfo.byteLength === 4 + 4 + ivLength, 'Malformed providerInfo');
        const tagLength = tagLengthBits / 8;
        /* Precondition: The encryptedDataKey byteLength must match the algorith suite specification and encoded length. */
        material_management_1.needs(encryptedDataKey.byteLength === tagLength + suite.keyLengthBytes, 'Malformed providerInfo');
        const iv = rawInfo.slice(-ivLength);
        const authTag = encryptedDataKey.slice(-tagLength);
        const ciphertext = encryptedDataKey.slice(0, -tagLength);
        return { authTag, ciphertext, iv };
    }
}
exports.rawAesEncryptedPartsFactory = rawAesEncryptedPartsFactory;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF3X2Flc19lbmNyeXB0ZWRfZGF0YV9rZXlzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Jhd19hZXNfZW5jcnlwdGVkX2RhdGFfa2V5cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7R0FhRzs7QUFFSDs7Ozs7Ozs7Ozs7SUFXSTtBQUVKLHFEQUErRDtBQUMvRCx5RUFJd0M7QUFFeEMsU0FBZ0IsNkJBQTZCLENBQzNDLE1BQXFDLEVBQ3JDLFFBQXVDO0lBRXZDLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxDQUFBO0lBRWpDLFNBQVMsc0JBQXNCLENBQzdCLFlBQW9CLEVBQ3BCLE9BQWUsRUFDZixFQUFjLEVBQ2QsVUFBc0IsRUFDdEIsT0FBbUI7UUFFbkIsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQTtRQUM5QixNQUFNLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFBO1FBQy9DLE1BQU0sZ0JBQWdCLEdBQUcseUJBQWEsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUE7UUFDM0QsTUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFBO1FBQy9CLE1BQU0sT0FBTyxHQUFHLHlCQUFhLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLG9CQUFRLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxvQkFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1FBQ3BHLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUNwQyxPQUFPLElBQUksc0NBQWdCLENBQUMsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUE7SUFDdEYsQ0FBQztBQUNILENBQUM7QUFyQkQsc0VBcUJDO0FBRUQsU0FBZ0IsMkJBQTJCLENBQUUsUUFBdUM7SUFDbEYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLENBQUE7SUFFL0IsU0FBUyxvQkFBb0IsQ0FDM0IsS0FBcUIsRUFDckIsT0FBZSxFQUNmLEVBQUUsZ0JBQWdCLEVBQUUsT0FBTyxFQUFvQjtRQUUvQyxpREFBaUQ7UUFDakQsSUFBSSxDQUFDLENBQUMsT0FBTyxZQUFZLFVBQVUsQ0FBQztZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQTtRQUN0RixvREFBb0Q7UUFDcEQsT0FBTyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBQ3JEOzs7OztZQUtJO1FBQ0osTUFBTSxRQUFRLEdBQUcsSUFBSSxRQUFRLENBQzNCLE9BQU8sQ0FBQyxNQUFNLEVBQ2QsT0FBTyxDQUFDLFVBQVUsRUFDbEIsT0FBTyxDQUFDLFVBQVUsQ0FDbkIsQ0FBQTtRQUNEOztZQUVJO1FBQ0osTUFBTSxhQUFhLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUEsQ0FBQyxhQUFhO1FBQ2hFLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFBLENBQUMsYUFBYTtRQUMzRCw2RUFBNkU7UUFDN0UsMkJBQUssQ0FBQyxRQUFRLEtBQUssS0FBSyxDQUFDLFFBQVEsRUFBRSx3QkFBd0IsQ0FBQyxDQUFBO1FBQzVELDhFQUE4RTtRQUM5RSwyQkFBSyxDQUFDLGFBQWEsS0FBSyxLQUFLLENBQUMsU0FBUyxFQUFFLHdCQUF3QixDQUFDLENBQUE7UUFDbEUsOEVBQThFO1FBQzlFLDJCQUFLLENBQUMsT0FBTyxDQUFDLFVBQVUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFFBQVEsRUFBRSx3QkFBd0IsQ0FBQyxDQUFBO1FBQ3hFLE1BQU0sU0FBUyxHQUFHLGFBQWEsR0FBRyxDQUFDLENBQUE7UUFDbkMsbUhBQW1IO1FBQ25ILDJCQUFLLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxLQUFLLFNBQVMsR0FBRyxLQUFLLENBQUMsY0FBYyxFQUFFLHdCQUF3QixDQUFDLENBQUE7UUFDakcsTUFBTSxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFBO1FBQ25DLE1BQU0sT0FBTyxHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFBO1FBQ2xELE1BQU0sVUFBVSxHQUFHLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQTtRQUV4RCxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsQ0FBQTtJQUNwQyxDQUFDO0FBQ0gsQ0FBQztBQTNDRCxrRUEyQ0MifQ==
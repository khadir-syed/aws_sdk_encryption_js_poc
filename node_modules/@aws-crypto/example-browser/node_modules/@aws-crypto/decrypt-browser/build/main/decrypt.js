"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const material_management_browser_1 = require("@aws-crypto/material-management-browser");
const serialize_1 = require("@aws-crypto/serialize");
const util_utf8_browser_1 = require("@aws-sdk/util-utf8-browser");
const deserialize = serialize_1.deserializeFactory(util_utf8_browser_1.toUtf8, material_management_browser_1.WebCryptoAlgorithmSuite);
const { messageAADContentString, messageAAD } = serialize_1.aadFactory(util_utf8_browser_1.fromUtf8);
async function decrypt(cmm, ciphertext) {
    /* If the cmm is a Keyring, wrap it with WebCryptoDefaultCryptographicMaterialsManager. */
    cmm = cmm instanceof material_management_browser_1.KeyringWebCrypto
        ? new material_management_browser_1.WebCryptoDefaultCryptographicMaterialsManager(cmm)
        : cmm;
    const headerInfo = deserialize.deserializeMessageHeader(ciphertext);
    if (headerInfo === false)
        throw new Error('Unable to parse Header');
    const { messageHeader } = headerInfo;
    const { rawHeader, headerIv, headerAuthTag } = headerInfo;
    const { encryptionContext, encryptedDataKeys, suiteId, messageId } = messageHeader;
    const suite = new material_management_browser_1.WebCryptoAlgorithmSuite(suiteId);
    const material = await cmm.decryptMaterials({ suite, encryptionContext, encryptedDataKeys });
    const { kdfGetSubtleDecrypt, subtleVerify, dispose } = await material_management_browser_1.getDecryptionHelper(material);
    const info = serialize_1.kdfInfo(suiteId, messageId);
    const getSubtleDecrypt = kdfGetSubtleDecrypt(info);
    // The tag is appended to the Data
    await getSubtleDecrypt(headerIv, rawHeader)(headerAuthTag); // will throw if invalid
    const { plaintext, readPos } = await bodyDecrypt({ buffer: ciphertext, getSubtleDecrypt, headerInfo });
    dispose();
    if (subtleVerify) {
        const data = ciphertext.slice(0, readPos);
        const signatureInfo = ciphertext.slice(readPos);
        const derSignature = serialize_1.deserializeSignature(signatureInfo);
        const rawSignature = serialize_1.der2raw(derSignature, material.suite);
        const isValid = await subtleVerify(rawSignature, data);
        /* Postcondition: subtleVerify must validate the signature. */
        material_management_browser_1.needs(isValid, 'Invalid Signature');
        return { messageHeader, plaintext };
    }
    else {
        return { messageHeader, plaintext };
    }
}
exports.decrypt = decrypt;
async function bodyDecrypt({ buffer, getSubtleDecrypt, headerInfo }) {
    let readPos = headerInfo.headerIv.byteLength + headerInfo.rawHeader.byteLength + headerInfo.headerAuthTag.byteLength;
    const clearBuffers = [];
    let sequenceNumber = 0;
    while (true) {
        /* Keeping track of the sequence number myself. */
        sequenceNumber += 1;
        const { clearBlob, frameInfo } = await framedDecrypt({ buffer, getSubtleDecrypt, headerInfo, readPos });
        /* Precondition: The sequenceNumber is required to monotonically increase, starting from 1.
         * This is to avoid a bad actor from abusing the sequence number on un-signed algorithm suites.
         * If the frame size matched the data format (say NDJSON),
         * then the data could be significantly altered just by rearranging the frames.
         * Non-framed data returns a sequenceNumber of 1.
         */
        material_management_browser_1.needs(frameInfo.sequenceNumber === sequenceNumber, 'Encrypted body sequence out of order.');
        clearBuffers.push(clearBlob);
        readPos = frameInfo.readPos;
        if (frameInfo.isFinalFrame) {
            const plaintext = serialize_1.concatBuffers(...clearBuffers);
            return { plaintext, readPos };
        }
    }
}
/* As we move to deprecate non-framed encrypt it is important to continue to support
 * non-framed decrypt.  The names not-withstanding, this supports non-framed decrypt
 * See decodeBodyHeader (it abstracts framed and non-framed body headers)
 */
async function framedDecrypt({ buffer, getSubtleDecrypt, headerInfo, readPos }) {
    const { messageHeader: { messageId } } = headerInfo;
    const frameInfo = serialize_1.decodeBodyHeader(buffer, headerInfo, readPos);
    if (!frameInfo)
        throw new Error('Format Error');
    const cipherLength = frameInfo.contentLength + frameInfo.tagLength / 8;
    const contentString = messageAADContentString(frameInfo);
    const messageAdditionalData = messageAAD(messageId, contentString, frameInfo.sequenceNumber, frameInfo.contentLength);
    const cipherBlob = buffer.slice(frameInfo.readPos, frameInfo.readPos + cipherLength);
    const clearBlob = await getSubtleDecrypt(frameInfo.iv, messageAdditionalData)(cipherBlob);
    frameInfo.readPos += cipherLength;
    return { clearBlob, frameInfo };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjcnlwdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWNyeXB0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7OztHQWFHOztBQUVILHlGQVFnRDtBQUNoRCxxREFVOEI7QUFDOUIsa0VBQTZEO0FBRTdELE1BQU0sV0FBVyxHQUFHLDhCQUFrQixDQUFDLDBCQUFNLEVBQUUscURBQXVCLENBQUMsQ0FBQTtBQUN2RSxNQUFNLEVBQUUsdUJBQXVCLEVBQUUsVUFBVSxFQUFFLEdBQUcsc0JBQVUsQ0FBQyw0QkFBUSxDQUFDLENBQUE7QUFPN0QsS0FBSyxVQUFVLE9BQU8sQ0FDM0IsR0FBK0MsRUFDL0MsVUFBc0I7SUFFdEIsMEZBQTBGO0lBQzFGLEdBQUcsR0FBRyxHQUFHLFlBQVksOENBQWdCO1FBQ25DLENBQUMsQ0FBQyxJQUFJLDJFQUE2QyxDQUFDLEdBQUcsQ0FBQztRQUN4RCxDQUFDLENBQUMsR0FBRyxDQUFBO0lBRVAsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLHdCQUF3QixDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ25FLElBQUksVUFBVSxLQUFLLEtBQUs7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUE7SUFDbkUsTUFBTSxFQUFFLGFBQWEsRUFBRSxHQUFHLFVBQVUsQ0FBQTtJQUNwQyxNQUFNLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsR0FBRyxVQUFVLENBQUE7SUFDekQsTUFBTSxFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxhQUFhLENBQUE7SUFDbEYsTUFBTSxLQUFLLEdBQUcsSUFBSSxxREFBdUIsQ0FBQyxPQUFPLENBQUMsQ0FBQTtJQUVsRCxNQUFNLFFBQVEsR0FBRyxNQUFNLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEtBQUssRUFBRSxpQkFBaUIsRUFBRSxpQkFBaUIsRUFB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
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import BN from 'bn.js';
import { ContentType, SequenceIdentifier } from './identifiers';
import { needs } from '@aws-crypto/material-management';
/*
 * This public interface for reading the BodyHeader format is provided for
 * the use of the Encryption SDK for JavaScript only.  It can be used
 * as a reference but is not intended to be use by any packages other
 * than the Encryption SDK for JavaScript.
 *
 * See:
 * https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#body-framing
 * https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/message-format.html#body-no-framing
 */
/**
 * decodeBodyHeader
 *
 * I need to be able to parse the BodyHeader, but since the data may be streamed
 * I may not have all the data yet.  The caller is expected to maintain and append
 * to the buffer and call this function with the same readPos until the function
 * returns a BodyHeader.
 *
 * @param buffer Uint8Array
 * @param headerInfo HeaderInfo
 * @param readPos number
 * @returns BodyHeader|false
 */
export function decodeBodyHeader(buffer, headerInfo, readPos) {
    /* Precondition: The contentType must be a supported format. */
    needs(ContentType[headerInfo.messageHeader.contentType], 'Unknown contentType');
    switch (headerInfo.messageHeader.contentType) {
        case ContentType.FRAMED_DATA:
            return decodeFrameBodyHeader(buffer, headerInfo, readPos);
        case ContentType.NO_FRAMING:
            return decodeNonFrameBodyHeader(buffer, headerInfo, readPos);
    }
    return false;
}
/**
 *  Exported for testing.  Used by decodeBodyHeader to compose a complete solution.
 * @param buffer Uint8Array
 * @param headerInfo HeaderInfo
 * @param readPos number
 */
export function decodeFrameBodyHeader(buffer, headerInfo, readPos) {
    /* Precondition: The contentType must be FRAMED_DATA. */
    needs(ContentType.FRAMED_DATA === headerInfo.messageHeader.contentType, 'Unknown contentType');
    const { frameLength } = headerInfo.messageHeader;
    const { ivLength, tagLength } = headerInfo.algorithmSuite;
    /* Uint8Array is a view on top of the underlying ArrayBuffer.
     * This means that raw underlying memory stored in the ArrayBuffer
     * may be larger than the Uint8Array.  This is especially true of
     * the Node.js Buffer object.  The offset and length *must* be
     * passed to the DataView otherwise I will get unexpected results.
     */
    const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    /* Precondition: decodeFrameBodyHeader readPos must be within the byte length of the buffer given. */
    needs(dataView.byteLength >= readPos && readPos >= 0, 'readPos out of bounds.');
    /* Check for early return (Postcondition): There must be enough data to decodeFrameBodyHeader.
     * The format expressed here is
     * SequenceIdentifier: Uint32
     * IVLength: Uint8
     * There is a special case where the SequenceIdentifier is the Final Frame.
     */
    if (4 + ivLength + readPos > dataView.byteLength)
        return false;
    const sequenceNumber = dataView.getUint32(readPos);
    /* Postcondition: decodeFrameBodyHeader sequenceNumber must be greater than 0. */
    needs(sequenceNumber > 0, 'Malformed sequenceNumber.');
    if (sequenceNumber === SequenceIdentifier.SEQUENCE_NUMBER_END) {
        return decodeFinalFrameBodyHeader(buffer, headerInfo, readPos);
    }
    const iv = buffer.slice(readPos += 4, readPos += ivLength);
    return {
        sequenceNumber,
        iv,
        contentLength: frameLength,
        readPos,
        tagLength,
        isFinalFrame: false,
        contentType: ContentType.FRAMED_DATA
    };
}
/**
 *  Exported for testing.  Used by decodeBodyHeader to compose a complete solution.
 * @param buffer Uint8Array
 * @param headerInfo HeaderInfo
 * @param readPos number
 */
export function decodeFinalFrameBodyHeader(buffer, headerInfo, readPos) {
    /* Precondition: The contentType must be FRAMED_DATA to be a Final Frame. */
    needs(ContentType.FRAMED_DATA === headerInfo.messageHeader.contentType, 'Unknown contentType');
    const { ivLength, tagLength } = headerInfo.algorithmSuite;
    /* Uint8Array is a view on top of the underlying ArrayBuffer.
     * This means that raw underlying memory stored in the ArrayBuffer
     * may be larger than the Uint8Array.  This is especially true of
     * the Node.js Buffer object.  The offset and length *must* be
     * passed to the DataView otherwise I will get unexpected results.
     */
    const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    /* Precondition: decodeFinalFrameBodyHeader readPos must be within the byte length of the buffer given. */
    needs(dataView.byteLength >= readPos && readPos >= 0, 'readPos out of bounds.');
    /* Check for early return (Postcondition): There must be enough data to decodeFinalFrameBodyHeader.
     * The format expressed here is
     * SEQUENCE_NUMBER_END: Uint32(FFFF)
     * SequenceIdentifier: Uint32
     * IVLength: Uint8
     * Reserved: Uint32
     * ContentLength: Uint32
     */
    if (4 + 4 + ivLength + 4 + readPos > dataView.byteLength)
        return false;
    /* The precondition SEQUENCE_NUMBER_END: Uint32(FFFF) is handled above. */
    const sequenceEnd = dataView.getUint32(readPos, false); // big endian
    /* Postcondition: sequenceEnd must be SEQUENCE_NUMBER_END. */
    needs(sequenceEnd === SequenceIdentifier.SEQUENCE_NUMBER_END, 'Malformed final frame: Invalid sequence number end value');
    const sequenceNumber = dataView.getUint32(readPos += 4, false); // big endian
    /* Postcondition: decodeFinalFrameBodyHeader sequenceNumber must be greater than 0. */
    needs(sequenceNumber > 0, 'Malformed sequenceNumber.');
    const iv = buffer.slice(readPos += 4, readPos += ivLength);
    const contentLength = dataView.getUint32(readPos);
    return {
        sequenceNumber,
        iv,
        contentLength,
        readPos: readPos + 4,
        tagLength,
        isFinalFrame: true,
        contentType: ContentType.FRAMED_DATA
    };
}
/**
 * Exported for testing.  Used by decodeBodyHeader to compose a complete solution.
 * @param buffer Uint8Array
 * @param headerInfo HeaderInfo
 * @param readPos number
 */
export function decodeNonFrameBodyHeader(buffer, headerInfo, readPos) {
    /* Precondition: The contentType must be NO_FRAMING. */
    needs(ContentType.NO_FRAMING === headerInfo.messageHeader.contentType, 'Unknown contentType');
    const { ivLength, tagLength } = headerInfo.algorithmSuite;
    /* Uint8Array is a view on top of the underlying ArrayBuffer.
     * This means that raw underlying memory stored in the ArrayBuffer
     * may be larger than the Uint8Array.  This is especially true of
     * the Node.js Buffer object.  The offset and length *must* be
     * passed to the DataView otherwise I will get unexpected results.
     */
    const dataView = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    /* Precondition: decodeNonFrameBodyHeader readPos must be within the byte length of the buffer given. */
    needs(dataView.byteLength >= readPos && readPos >= 0, 'readPos out of bounds.');
    /* Check for early return (Postcondition): There must be enough data to decodeNonFrameBodyHeader.
      * The format expressed here is
      * IVLength: Uint8
      * ContentLength: Uint64
      */
    if (ivLength + 8 + readPos > dataView.byteLength)
        return false;
    const iv = buffer.slice(readPos, readPos += ivLength);
    const contentLengthBuff = buffer.slice(readPos, readPos += 8);
    const contentLengthBN = new BN([...contentLengthBuff], 16, 'be');
    // This will throw if the number is larger than Number.MAX_SAFE_INTEGER.
    // i.e. a 53 bit number
    const contentLength = contentLengthBN.toNumber();
    return {
        sequenceNumber: 1,
        iv,
        contentLength,
        readPos,
        tagLength,
        isFinalFrame: true,
        contentType: ContentType.NO_FRAMING
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb2RlX2JvZHlfaGVhZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RlY29kZV9ib2R5X2hlYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUgsT0FBTyxFQUFFLE1BQU0sT0FBTyxDQUFBO0FBQ3RCLE9BQU8sRUFBRSxXQUFXLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxlQUFlLENBQUE7QUFFL0QsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGlDQUFpQyxDQUFBO0FBRXZEOzs7Ozs7Ozs7R0FTRztBQUVIOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBRSxNQUFrQixFQUFFLFVBQXNCLEVBQUUsT0FBZTtJQUMzRiwrREFBK0Q7SUFDL0QsS0FBSyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxFQUFFLHFCQUFxQixDQUFDLENBQUE7SUFFL0UsUUFBUSxVQUFVLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRTtRQUM1QyxLQUFLLFdBQVcsQ0FBQyxXQUFXO1lBQzFCLE9BQU8scUJBQXFCLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQTtRQUMzRCxLQUFLLFdBQVcsQ0FBQyxVQUFVO1lBQ3pCLE9BQU8sd0JBQXdCLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQTtLQUMvRDtJQUNELE9BQU8sS0FBSyxDQUFBO0FBQ2QsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQixDQUFFLE1BQWtCLEVBQUUsVUFBc0IsRUFBRSxPQUFlO0lBQ2hHLHdEQUF3RDtJQUN4RCxLQUFLLENBQUMsV0FBVyxDQUFDLFdBQVcsS0FBSyxVQUFVLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxxQkFBcUIsQ0FBQyxDQUFBO0lBRTlGLE1BQU0sRUFBRSxXQUFXLEVBQUUsR0FB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
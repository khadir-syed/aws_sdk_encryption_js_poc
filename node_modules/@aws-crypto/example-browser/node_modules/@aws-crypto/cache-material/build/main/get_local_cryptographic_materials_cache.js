"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lru_cache_1 = __importDefault(require("lru-cache"));
const material_management_1 = require("@aws-crypto/material-management");
function getLocalCryptographicMaterialsCache(capacity, proactiveFrequency = 1000 * 60) {
    const cache = new lru_cache_1.default({
        max: capacity,
        dispose(_key, value) {
            /* Zero out the unencrypted dataKey, when the material is removed from the cache. */
            value.response.zeroUnencryptedDataKey();
        }
    });
    (function proactivelyTryAndEvictTail() {
        const timeout = setTimeout(() => {
            mayEvictTail();
            proactivelyTryAndEvictTail();
        }, proactiveFrequency);
        /* In Node.js the event loop will _only_ exit if there are no outstanding events.
         * This means that if I did nothing the event loop would *always* be blocked.
         * This is unfortunate and very bad for things like Lambda.
         * So, I tell Node.js to not wait for this timer.
         * See: https://nodejs.org/api/timers.html#timers_timeout_unref
         */
        // @ts-ignore
        timeout.unref && timeout.unref();
    })();
    return {
        putEncryptionMaterial(key, material, plaintextLength, maxAge) {
            /* Precondition: putEncryptionMaterial plaintextLength can not be negative. */
            material_management_1.needs(plaintextLength >= 0, 'Malformed plaintextLength');
            /* Precondition: Only cache EncryptionMaterial. */
            material_management_1.needs(material_management_1.isEncryptionMaterial(material), 'Malformed response.');
            /* Precondition: Only cache EncryptionMaterial that is cacheSafe. */
            material_management_1.needs(material.suite.cacheSafe, 'Can not cache non-cache safe material');
            const entry = Object.seal({
                response: material,
                bytesEncrypted: plaintextLength,
                messagesEncrypted: 1,
                now: Date.now()
            });
            cache.set(key, entry, maxAge);
        },
        putDecryptionMaterial(key, material, maxAge) {
            /* Precondition: Only cache DecryptionMaterial. */
            material_management_1.needs(material_management_1.isDecryptionMaterial(material), 'Malformed response.');
            /* Precondition: Only cache DecryptionMaterial that is cacheSafe. */
            material_management_1.needs(material.suite.cacheSafe, 'Can not cache non-cache safe material');
            const entry = Object.seal({
                response: material,
                bytesEncrypted: 0,
                messagesEncrypted: 0,
                now: Date.now()
            });
            cache.set(key, entry, maxAge);
        },
        getEncryptionMaterial(key, plaintextLength) {
            /* Precondition: plaintextLength can not be negative. */
            material_management_1.needs(plaintextLength >= 0, 'Malformed plaintextLength');
            const entry = cache.get(key);
            /* Check for early return (Postcondition): If this key does not have an EncryptionMaterial, return false. */
            if (!entry)
                return false;
            /* Postcondition: Only return EncryptionMaterial. */
            material_management_1.needs(material_management_1.isEncryptionMaterial(entry.response), 'Malformed response.');
            entry.bytesEncrypted += plaintextLength;
            entry.messagesEncrypted += 1;
            return entry;
        },
        getDecryptionMaterial(key) {
            const entry = cache.get(key);
            /* Check for early return (Postcondition): If this key does not have a DecryptionMaterial, return false. */
            if (!entry)
                return false;
            /* Postcondition: Only return DecryptionMaterial. */
            material_management_1.needs(material_management_1.isDecryptionMaterial(entry.response), 'Malformed response.');
            return entry;
        },
        del(key) {
            cache.del(key);
        }
    };
    function mayEvictTail() {
        // @ts-ignore
        const { tail } = cache.dumpLru();
        /* Check for early return (Postcondition) UNTESTED: If there is no tail, then the cache is empty. */
        if (!tail)
            return;
        /* The underlying Yallist tail Node has a `value`.
         * This value is a lru-cache Entry and has a `key`.
         */
        const { key } = tail.value;
        // Peek will evict, but not update the "recently used"-ness of the key.
        cache.peek(key);
    }
}
exports.getLocalCryptographicMaterialsCache = getLocalCryptographicMaterialsCache;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0X2xvY2FsX2NyeXB0b2dyYXBoaWNfbWF0ZXJpYWxzX2NhY2hlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2dldF9sb2NhbF9jcnlwdG9ncmFwaGljX21hdGVyaWFsc19jYWNoZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7R0FhRzs7Ozs7QUFFSCwwREFBMkI7QUFDM0IseUVBT3dDO0FBU3hDLFNBQWdCLG1DQUFtQyxDQUNqRCxRQUFnQixFQUNoQixxQkFBNkIsSUFBSSxHQUFHLEVBQUU7SUFFdEMsTUFBTSxLQUFLLEdBQUcsSUFBSSxtQkFBRyxDQUFtQjtRQUN0QyxHQUFHLEVBQUUsUUFBUTtRQUNiLE9BQU8sQ0FBRSxJQUFJLEVBQUUsS0FBSztZQUNsQixvRkFBb0Y7WUFDcEYsS0FBSyxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsRUFBRSxDQUFBO1FBQ3pDLENBQUM7S0FDRixDQUFDLENBZUQ7SUFBQSxDQUFDLFNBQVMsMEJBQTBCO1FBQ25DLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUU7WUFDOUIsWUFBWSxFQUFFLENBQUE7WUFDZCwwQkFBMEIsRUFBRSxDQUFBO1FBQzlCLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFBO1FBQ3RCOzs7OztXQUtHO1FBQ0gsYUFBYTtRQUNiLE9BQU8sQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFBO0lBQ2xDLENBQUMsQ0FBQyxFQUFFLENBQUE7SUFFSixPQUFPO1FBQ0wscUJBQXFCLENBQ25CLEdBQVcsRUFDWCxRQUErQixFQUMvQixlQUF1QixFQUN2QixNQUFlO1lBRWYsOEVBQThFO1lBQzlFLDJCQUFLLENBQUMsZUFBZSxJQUFJLENBQUMsRUFBRSwyQkFBMkIsQ0FBQyxDQUFBO1lBQ3hELGtEQUFrRDtZQUNsRCwyQkFBSyxDQUFDLDBDQUFvQixDQUFDLFFBQVEsQ0FBQyxFQUFFLHFCQUFxQixDQUFDLENBQUE7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
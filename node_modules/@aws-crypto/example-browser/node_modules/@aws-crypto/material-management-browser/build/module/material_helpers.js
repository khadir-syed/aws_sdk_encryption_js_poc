/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { needs, // eslint-disable-line no-unused-vars
isCryptoKey, isValidCryptoKey, keyUsageForMaterial, subtleFunctionForMaterial, unwrapDataKey } from '@aws-crypto/material-management';
import { getWebCryptoBackend, getNonZeroByteBackend, getZeroByteSubtle, isFullSupportWebCryptoBackend } from '@aws-crypto/web-crypto-backend';
import { bytes2JWK } from './bytes2_jwk';
export const getEncryptHelper = async (material) => {
    const backend = await getWebCryptoBackend();
    /* Precondition: WebCryptoEncryptionMaterial must have a valid data key. */
    needs(material.hasValidKey(), 'Material has no CryptoKey.');
    const { signatureHash } = material.suite;
    const kdfGetSubtleEncrypt = getSubtleFunction(material, backend, 'encrypt');
    return Object.freeze({
        kdfGetSubtleEncrypt,
        subtleSign: signatureHash ? getSubtleSign : undefined,
        dispose
    });
    function getSubtleSign(data) {
        if (!signatureHash)
            throw new Error('Algorithm suite does not support signing.');
        const { signatureKey } = material;
        if (!signatureKey)
            throw new Error('Malformed Material.');
        const { privateKey } = signatureKey;
        if (!isCryptoKey(privateKey))
            throw new Error('Malformed Material.');
        const algorithm = { name: 'ECDSA', hash: { name: signatureHash } };
        return getNonZeroByteBackend(backend).sign(algorithm, privateKey, data);
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
export const getDecryptionHelper = async (material) => {
    const backend = await getWebCryptoBackend();
    /* Precondition: WebCryptoDecryptionMaterial must have a valid data key. */
    needs(material.hasValidKey(), 'Material has no valid data key.');
    const { signatureHash } = material.suite;
    const kdfGetSubtleDecrypt = getSubtleFunction(material, backend, 'decrypt');
    return Object.freeze({
        kdfGetSubtleDecrypt,
        subtleVerify: signatureHash ? subtleVerify : undefined,
        dispose
    });
    function subtleVerify(signature, data) {
        if (!signatureHash)
            throw new Error('Algorithm suite does not support signing.');
        const { verificationKey } = material;
        if (!verificationKey)
            throw new Error('Malformed Material.');
        const { publicKey } = verificationKey;
        if (!isCryptoKey(publicKey))
            throw new Error('Malformed Material.');
        const algorithm = { name: 'ECDSA', hash: { name: signatureHash } };
        return getNonZeroByteBackend(backend).verify(algorithm, publicKey, signature, data);
    }
    function dispose() {
        material.zeroUnencryptedDataKey();
    }
};
export function getSubtleFunction(material, backend, subtleFunction = subtleFunctionForMaterial(material)) {
    /* Precondition: The material must have a CryptoKey. */
    needs(material.hasCryptoKey, 'Material must have a CryptoKey.');
    const cryptoKey = material.getCryptoKey();
    /* Precondition: The cryptoKey and backend must match in terms of Mixed vs Full support. */
    needs(isCryptoKey(cryptoKey) === isFullSupportWebCryptoBackend(backend), 'CryptoKey vs WebCrypto backend mismatch.');
    const { suite } = material;
    const { encryption: cipherName, ivLength, tagLength } = suite;
    return (info) => {
        const derivedKeyPromise = isCryptoKey(cryptoKey)
            ? WebCryptoKdf(getNonZeroByteBackend(backend), material, cryptoKey, [subtleFunction], info)
            : Promise.all([
                WebCryptoKdf(getNonZeroByteBackend(backend), material, cryptoKey.nonZeroByteCryptoKey, [subtleFunction], info),
                WebCryptoKdf(getZeroByteSubtle(backend), material, cryptoKey.zeroByteCryptoKey, [subtleFunction], info)
            ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({ nonZeroByteCryptoKey, zeroByteCryptoKey }));
        return (iv, additionalData) => {
            /* Precondition: The length of the IV must match the WebCryptoAlgorithmSuite specification. */
            needs(iv.byteLength === ivLength, 'Iv length does not match algorithm suite specification');
            return async (data) => {
                const deriveKey = await derivedKeyPromise;
                if (isCryptoKey(deriveKey) && isFullSupportWebCryptoBackend(backend)) {
                    const { subtle } = backend;
                    const algorithm = { name: cipherName, iv, additionalData, tagLength };
                    return subtle[subtleFunction](algorithm, deriveKey, data);
                }
                else if (!isCryptoKey(deriveKey) && !isFullSupportWebCryptoBackend(backend)) {
                    const { nonZeroByteSubtle, zeroByteSubtle } = backend;
                    const { nonZeroByteCryptoKey, zeroByteCryptoKey } = deriveKey;
                    const algorithm = { name: cipherName, iv, additionalData, tagLength };
                    if (data.byteLength) {
                        return nonZeroByteSubtle[subtleFunction](algorithm, nonZeroByteCryptoKey, data);
                    }
                    else {
                        return zeroByteSubtle[subtleFunction](algorithm, zeroByteCryptoKey, data);
                    }
                }
                // This should be impossible
                throw new Error('Unknown Error');
            };
        };
    };
}
export async function WebCryptoKdf(subtle, material, cryptoKey, keyUsages, info) {
    const { kdf, kdfHash, keyLength, encryption } = material.suite;
    /* Check for early return (Postcondition): No WebCrypto KDF, just return the unencrypted data key. */
    if (!kdf && !kdfHash)
        return cryptoKey;
    /* Precondition: Valid HKDF values must exist for browsers. */
    needs(kdf === 'HKDF' &&
        kdfHash &&
        info instanceof Uint8Array &&
        info.byteLength, 'Invalid HKDF values.');
    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    const kdfAlgorithm = { name: kdf, hash: { name: kdfHash }, info, salt: new Uint8Array() };
    const derivedKeyAlgorithm = { name: encryption, length: keyLength };
    const extractable = false;
    const deriveKey = await subtle
        .deriveKey(
    // @ts-ignore types need to be updated see: https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams
    kdfAlgorithm, cryptoKey, derivedKeyAlgorithm, extractable, keyUsages);
    /* Postcondition: The derived key must conform to the algorith suite specification. */
    needs(isValidCryptoKey(deriveKey, material), 'Invalid derived key');
    return deriveKey;
}
export async function importCryptoKey(backend, material, keyUsages = [keyUsageForMaterial(material)]) {
    if (isFullSupportWebCryptoBackend(backend)) {
        return _importCryptoKey(backend.subtle, material, keyUsages);
    }
    else {
        return Promise.all([
            _importCryptoKey(getNonZeroByteBackend(backend), material, keyUsages),
            _importCryptoKey(getZeroByteSubtle(backend), material, keyUsages)
        ]).then(([nonZeroByteCryptoKey, zeroByteCryptoKey]) => ({ nonZeroByteCryptoKey, zeroByteCryptoKey }));
    }
}
export async function _importCryptoKey(subtle, material, keyUsages = [keyUsageForMaterial(material)]) {
    const { suite } = material;
    const extractable = false;
    const udk = unwrapDataKey(material.getUnencryptedDataKey());
    if (suite.kdf) {
        /* For several browsers, import for a key to derive with HKDF
         * *must* be raw.  This may cause some compatibility issues
         * with browsers that need a zero byte gcm fallback.
         */
        const format = 'raw';
        const algorithm = suite.kdf;
        return subtle.importKey(format, udk, algorithm, extractable, keyUsages);
    }
    else {
        const format = 'jwk';
        const algorithm = suite.encryption;
        const jwk = bytes2JWK(udk);
        return subtle.importKey(format, jwk, algorithm, extractable, keyUsages);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0ZXJpYWxfaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXRlcmlhbF9oZWxwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFFSCxPQUFPLEVBQ0wsS0FBSyxFQUdrQixxQ0FBcUM7QUFDNUQsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixtQkFBbUIsRUFDbkIseUJBQXlCLEVBQ3pCLGFBQWEsRUFFZCxNQUFNLGlDQUFpQyxDQUFBO0FBRXhDLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIscUJBQXFCLEVBQ3JCLGlCQUFpQixFQUNqQiw2QkFBNkIsRUFFOUIsTUFBTSxnQ0FBZ0MsQ0FBQTtBQUV2QyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFBO0FBd0J4QyxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBcUIsS0FBSyxFQUFFLFFBQXFDLEVBQUUsRUFBRTtJQUNoRyxNQUFNLE9BQU8sR0FBRyxNQUFNLG1CQUFtQixFQUFFLENBQUE7SUFFM0MsMkVBQTJFO0lBQzNFLEtBQUssQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLEVBQUUsNEJBQTRCLENBQUMsQ0FBQTtJQUUzRCxNQUFNLEVBQUUsYUFBYSxFQUFFLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQTtJQUN4QyxNQUFNLG1CQUFtQixHQUF3QixpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFBO0lBQ2hHLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNuQixtQkFBbUI7UUFDbkIsVUFBVSxFQUFFLGFBQWEsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxTQUFTO1FBQ3JELE9BQU87S0FDUixDQUFDLENBQUE7SUFFRixTQUFTLGFBQWEsQ0FBRSxJQUFnQjtRQUN0QyxJQUFJLENBQUMsYUFBYTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMs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
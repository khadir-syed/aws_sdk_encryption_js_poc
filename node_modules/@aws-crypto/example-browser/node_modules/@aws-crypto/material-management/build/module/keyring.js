/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { EncryptedDataKey } from './encrypted_data_key';
import { immutableBaseClass, immutableClass } from './immutable_class';
import { isEncryptionMaterial, isDecryptionMaterial } from './cryptographic_material';
import { needs } from './needs';
/*
 * This public interface to the Keyring object is provided for
 * developers of CMMs and keyrings only. If you are a user of the AWS Encryption
 * SDK and you are not developing your own CMMs and/or keyrings, you do not
 * need to use it and you should not do so.
 */
export class Keyring {
    async onEncrypt(material) {
        /* Precondition: material must be a type of isEncryptionMaterial.
         * There are several security properties that NodeEncryptionMaterial and WebCryptoEncryptionMaterial
         * posses.
         * The unencryptedDataKey can only be written once.
         * If a data key has not already been generated, there must be no EDKs.
         * See cryptographic_materials.ts
         */
        needs(isEncryptionMaterial(material), 'Unsupported type of material.');
        const _material = await this._onEncrypt(material);
        /* Postcondition: The EncryptionMaterial objects must be the same.
         * See cryptographic_materials.ts.  The CryptographicMaterial objects
         * provide several security properties, including immutability of
         * the unencrypted data key and the ability to zero the data key.
         * This is insured by returning the same material.
         */
        needs(material === _material, 'New EncryptionMaterial instances can not be created.');
        /* Postcondition UNTESTED: If this keyring generated data key, it must be the right length.
         * See cryptographic_materials.ts This is handled in setUnencryptedDataKey
         * this condition is listed here to keep help keep track of important conditions
        */
        return material;
    }
    /* NOTE: The order of EDK's passed to the onDecrypt function is a clear
     * intent on the part of the person who did the encryption.
     * The EDK's should always correspond to the order serialized.
     * It is the Keyrings responsibility to maintain this order.
     * The most clear example is from KMS.  KMS is a regional service.
     * This means that a call to decrypt an EDK must go to the
     * region that "owns" this EDK.  If the decryption is done
     * in a different region. To control this behavior the person
     * who called encrypt can control the order of EDK and in the
     * configuration of the KMS Keyring.
     */
    async onDecrypt(material, encryptedDataKeys) {
        /* Precondition: material must be DecryptionMaterial. */
        needs(isDecryptionMaterial(material), 'Unsupported material type.');
        /* Precondition: Attempt to decrypt iif material does not have an unencrypted data key. */
        if (material.hasValidKey())
            return material;
        /* Precondition: encryptedDataKeys must all be EncryptedDataKey. */
        needs(encryptedDataKeys.every(edk => edk instanceof EncryptedDataKey), 'Unsupported EncryptedDataKey type');
        const _material = await this._onDecrypt(material, encryptedDataKeys);
        /* Postcondition: The DecryptionMaterial objects must be the same.
         * See cryptographic_materials.ts.  The CryptographicMaterial objects
         * provide several security properties, including immutability of
         * the unencrypted data key and the ability to zero the data key.
         * This is insured by returning the same material.
         */
        needs(material === _material, 'New DecryptionMaterial instances can not be created.');
        /* See cryptographic_materials.ts The length condition is handled there.
         * But the condition is important and so repeated here.
         * The postcondition is "If an EDK was decrypted, its length must agree with algorithm specification."
         * If this is not the case, it either means ciphertext was tampered
         * with or the keyring implementation is not setting the length properly.
         */
        return material;
    }
}
immutableBaseClass(Keyring);
export class KeyringNode extends Keyring {
}
immutableClass(KeyringNode);
export class KeyringWebCrypto extends Keyring {
}
immutableClass(KeyringWebCrypto);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5cmluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9rZXlyaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFFSCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQTtBQUN2RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUE7QUFFdEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLE1BQU0sMEJBQTBCLENBQUE7QUFFckYsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLFNBQVMsQ0FBQTtBQUkvQjs7Ozs7R0FLRztBQUVILE1BQU0sT0FBZ0IsT0FBTztJQUMzQixLQUFLLENBQUMsU0FBUyxDQUFFLFFBQStCO1FBQzlDOzs7Ozs7V0FNRztRQUNILEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsRUFBRSwrQkFBK0IsQ0FBQyxDQUFBO1FBRXRFLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUVqRDs7Ozs7V0FLRztRQUNILEtBQUssQ0FBQyxRQUFRLEtBQUssU0FBUyxFQUFFLHNEQUFzRCxDQUFDLENBQUE7UUFFckY7OztVQUdFO1FBRUYsT0FBTyxRQUFRLENBQUE7SUFDakIsQ0FBQztJQUlEOzs7Ozs7Ozs7O09BVUc7SUFDSCxLQUFLLENBQUMsU0FBUyxDQUFFLFFBQStCLEVBQUUsaUJBQXFDO1FBQ3JGLHdEQUF3RDtRQUN4RCxLQUFLLENBQUMsb0JBQW9CLENBQUMsUUFBUSxDQUFDLEVBQUUsNEJBQTRCLENBQUMsQ0FBQTtRQUVuRSwwRkFBMEY7UUFDMUYsSUFBSSxRQUFRLENBQUMsV0FBVyxFQUFFO1lBQUUsT0FBTyxRQUFRLENBQUE7UUFFM0MsbUVBQW1FO1FBQ25FLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksZ0JBQWdCLENBQUMsRUFBRSxtQ0FBbUMsQ0FBQyxDQUFBO1FBRTNHLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsaUJBQWlCLENBQUMsQ0FBQTtRQUVwRTs7Ozs7V0FLRztRQUNILEtBQUssQ0FBQyxRQUFRLEtBQUssU0FBUyxFQUFFLHNEQUFzRCxDQUFDLENBQUE7UUFFckY7Ozs7O1dBS0c7UUFFSCxPQUFPLFFBQVEsQ0FBQTtJQUNqQixDQUFDO0NBR0Y7QUFFRCxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQTtBQUUzQixNQUFNLE9BQWdCLFdBQVksU0FBUSxPQUEyQjtDQUFHO0FBQ3hFLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQTtBQUMzQixNQUFNLE9BQWdCLGdCQUFpQixTQUFRLE9BQWdDO0NBQUc7QUFDbEYsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUEifQ==
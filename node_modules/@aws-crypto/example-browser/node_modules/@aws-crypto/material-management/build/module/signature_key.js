/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use
 * this file except in compliance with the License. A copy of the License is
 * located at
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the "license" file accompanying this file. This file is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { encodeNamedCurves } from './ecc_encode';
import { decodeNamedCurves } from './ecc_decode';
import { frozenClass, readOnlyBinaryProperty, readOnlyProperty } from './immutable_class';
import { publicKeyPem, privateKeyPem } from './pem_helpers';
/*
 * This public interface to the SignatureKey object is provided for
 * developers of CMMs and keyrings only. If you are a user of the AWS Encryption
 * SDK and you are not developing your own CMMs and/or keyrings, you do not
 * need to use it and you should not do so.
 */
export class SignatureKey {
    constructor(privateKey, compressPoint, suite) {
        const { signatureCurve: namedCurve } = suite;
        /* Precondition: Do not create a SignatureKey for an algorithm suite that does not have an EC named curve. */
        if (!namedCurve)
            throw new Error('Unsupported Algorithm');
        /* This is unfortunately complicated.  Node v11 crypto will accept
         * a PEM formated Buffer to sign.  But the ECDH class will still
         * return Buffers that are not PEM formated, but _only_ the points
         * on the curve.  This means I have to make a choice about
         * formating.  I chose to assume that t Buffer/Uin8Array is
         * _only_ the raw points.
         */
        if (privateKey instanceof Uint8Array) {
            const pem = privateKeyPem(namedCurve, fromBuffer(privateKey), fromBuffer(compressPoint));
            readOnlyProperty(this, 'privateKey', pem);
        }
        else {
            readOnlyProperty(this, 'privateKey', privateKey);
        }
        readOnlyBinaryProperty(this, 'compressPoint', compressPoint);
        readOnlyProperty(this, 'signatureCurve', namedCurve);
        Object.setPrototypeOf(this, SignatureKey.prototype);
        Object.freeze(this);
    }
    static encodeCompressPoint(publicKeyBytes, suite) {
        const { signatureCurve: namedCurve } = suite;
        /* Precondition: Do not return a compress point for an algorithm suite that does not have an EC named curve. */
        if (!namedCurve)
            throw new Error('Unsupported Algorithm');
        return encodeNamedCurves[namedCurve](publicKeyBytes);
    }
}
frozenClass(SignatureKey);
export class VerificationKey {
    constructor(publicKey, suite) {
        const { signatureCurve: namedCurve } = suite;
        /* Precondition: Do not create a VerificationKey for an algorithm suite that does not have an EC named curve. */
        if (!namedCurve)
            throw new Error('Unsupported Algorithm');
        /* This is unfortunately complicated.  Node v11 crypto will accept
         * a PEM formated Buffer to verify.  But the ECDH class will still
         * return Buffers that are not PEM formated, but _only_ the points
         * on the curve.  This means I have to make a choice about
         * formating.  I chose to assume that the Buffer/Uin8Array is
         * _only_ the raw points.
         */
        if (publicKey instanceof Uint8Array) {
            const pem = publicKeyPem(namedCurve, fromBuffer(publicKey));
            readOnlyProperty(this, 'publicKey', pem);
        }
        else {
            readOnlyProperty(this, 'publicKey', publicKey);
        }
        readOnlyProperty(this, 'signatureCurve', namedCurve);
        Object.setPrototypeOf(this, VerificationKey.prototype);
        Object.freeze(this);
    }
    static decodeCompressPoint(compressPoint, suite) {
        const { signatureCurve: namedCurve } = suite;
        /* Precondition: Do not decode a public key for an algorithm suite that does not have an EC named curve. */
        if (!namedCurve)
            throw new Error('Unsupported Algorithm');
        return decodeNamedCurves[namedCurve](compressPoint);
    }
}
frozenClass(VerificationKey);
function fromBuffer(uint) {
    const { buffer, byteOffset, byteLength } = uint;
    return Buffer.from(buffer, byteOffset, byteLength);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbmF0dXJlX2tleS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaWduYXR1cmVfa2V5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFHSCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxjQUFjLENBQUE7QUFDaEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sY0FBYyxDQUFBO0FBQ2hELE9BQU8sRUFBRSxXQUFXLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQTtBQUN6RixPQUFPLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxNQUFNLGVBQWUsQ0FBQTtBQUczRDs7Ozs7R0FLRztBQUVILE1BQU0sT0FBTyxZQUFZO0lBSXZCLFlBQWEsVUFBeUMsRUFBRSxhQUF5QixFQUFFLEtBQXFCO1FBQ3RHLE1BQU0sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLEdBQUcsS0FBSyxDQUFBO1FBQzVDLDZHQUE2RztRQUM3RyxJQUFJLENBQUMsVUFBVTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQTtRQUN6RDs7Ozs7O1dBTUc7UUFDSCxJQUFJLFVBQVUsWUFBWSxVQUFVLEVBQUU7WUFDcEMsTUFBTSxHQUFHLEdBQUcsYUFBYSxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUUsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUE7WUFDeEYsZ0JBQWdCLENBQTZCLElBQUksRUFBRSxZQUFZLEVBQUUsR0FBRyxDQUFDLENBQUE7U0FDdEU7YUFBTTtZQUNMLGdCQUFnQixDQUE2QixJQUFJLEVBQUUsWUFBWSxFQUFFLFVBQVUsQ0FBQyxDQUFBO1NBQzdFO1FBQ0Qsc0JBQXNCLENBQUMsSUFBSSxFQUFFLGVBQWUsRUFBRSxhQUFhLENBQUMsQ0FBQTtRQUM1RCxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLENBQUE7UUFDcEQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFBO1FBQ25ELE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDckIsQ0FBQztJQUVELE1BQU0sQ0FBQyxtQkFBbUIsQ0FBRSxjQUEwQixFQUFFLEtBQXFCO1FBQzNFLE1BQU0sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLEdBQUcsS0FBSyxDQUFBO1FBQzVDLCtHQUErRztRQUMvRyxJQUFJLENBQUMsVUFBVTtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQTtRQUN6RCxPQUFPLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFBO0lBQ3RELENBQUM7Q0FDRjtBQUNELFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQTtBQUV6QixNQUFNLE9BQU8sZUFBZTtJQUcxQixZQUFhLFNBQXdDLEVBQUUsS0FBcUI7UUFDMUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsR0FBRyxLQUFLLENBQUE7UUFDNUMsZ0hBQWdIO1FBQ2hILElBQUksQ0FBQyxVQUFVO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFBO1FBQ3pEOzs7Ozs7V0FNRztRQUNILElBQUksU0FBUyxZQUFZLFVBQVUsRUFBRTtZQUNuQyxNQUFNLEdBQUcsR0FBRyxZQUFZLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFBO1lBQzNELGdCQUFnQixDQUErQixJQUFJLEVBQUUsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFBO1NBQ3ZFO2FBQU07WUFDTCxnQkFBZ0IsQ0FBK0IsSUFBSSxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQTtTQUM3RTtRQUNELGdCQUFnQixDQUFDLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLENBQUMsQ0FBQTtRQUNwRCxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUE7UUFDdEQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQTtJQUNyQixDQUFDO0lBRUQsTUFBTSxDQUFDLG1CQUFtQixDQUFFLGFBQXlCLEVBQUUsS0FBcUI7UUFDMUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsR0FBRyxLQUFLLENBQUE7UUFDNUMsMkdBQTJHO1FBQzNHLElBQUksQ0FBQyxVQUFVO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFBO1FBRXpELE9BQU8saUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUE7SUFDckQsQ0FBQztDQUNGO0FBQ0QsV0FBVyxDQUFDLGVBQWUsQ0FBQyxDQUFBO0FBRTVCLFNBQVMsVUFBVSxDQUFFLElBQWdCO0lBQ25DLE1BQU0sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxHQUFHLElBQUksQ0FBQTtJQUMvQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQTtBQUNwRCxDQUFDIn0=